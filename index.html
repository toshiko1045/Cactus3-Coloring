<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Color the cactus graph with three colors</title>
<style>
    html{
        height: 100%;
        width: 100%;
    }
    body {
        width: 100%;
        height: 100%;
        display: flex;
        column-gap: 1%;
    }
    #canvasContainer{
        display: flex;
        justify-content: center;
        align-items: center;
    }
    #textAndButtonContainer{
        height: 75%;
        justify-content: center;
        align-items: center;
        margin: 10% auto;
    }
    #processArea{
        height: 50%;
        width: 200pt;
        overflow: scroll;
        white-space: pre-line
    }
    #myButtons{
        /* height: 25%; */
        width: 50%;
    }
    canvas {
        border: 10px solid gray;
        cursor: default;
        border-radius: 40px 40px 40px 40px;
        margin: 5% auto;
    }
</style>
</head>
<body>
    <div id="canvasContainer">
        <canvas id="myCanvas"></canvas>
    </div>
    <div id="textAndButtonContainer">
        <div id="myButtons">
            <input type="button" value="make random cactus graph" onclick="redrawRandomCactusGraph()">
            <input type="button" value="make random uncactus graph" onclick="redrawRandomUnCactusGraph()">
            <input type="button" value="check cactus graph" onclick="doCheckCactusGraph()">
            <input type="button" value="test check cactus graph" onclick="doTestCheckCactusGraph()">
            <input type="button" value="test check uncactus graph" onclick="doTestCheckUnCactusGraph()">
            <!-- <input type="button" value="do minimize" onclick="redrawMinimumGraph()"> -->
            <input type="button" value="coloring graph" onclick="doColoring()">
            <input type="button" value="step coloring graph" onclick="stepColoring()">
            <input type="button" value="show status" onclick="showStatus()">
            <input type="button" value="make balanced graph" onclick="switchMakeBlancedGraph()">
            <input type="button" value="undo" onclick="undo()">
            <input type="button" value="redo" onclick="redo()">
            <input type="button" value="change color" onclick="changeColor()">
            <input type="button" value="change x" onclick="changeX()">
            <input type="text" id="graphName">
            <input type="button" value="save" onclick="saveGraph()">
            <select id="loadGraphName"></select>
            <input type="button" value="load" onclick="loadGraph()">
            <input type="button" value="delete" onclick="deleteGraph()">
            <input type="number" value=0 id="changedX">
            <input type="number" value=7 id="graphSize">
            <input type="number" value=7 id="graphComplex">
            <input type="number" value=15 id="xRange">
            <input type="range" min="1" max="100" value="100" id="circleSize">
            <input type="range" min="1" max="100" value="100" id="gravitySize">
        </div>
        <div id="processArea"></div>
    </div>

<script>
    const canvas = document.getElementById('myCanvas');
    const ctx = canvas.getContext('2d');
    let Nodes = []; //{x, y, index, p, c, in, out}
    let Edges = []; //{Node1ID, Node2ID}
    let clickedNodeId = -1;
    let lastEvent = "";
    let edgeStartNodeId = -1;
    let isDrawingEdge = false;
    let isFinishedMove = true;
    let circleSize = 0;
    let nodeIdNow = 0;
    let Color = [0,1,2];//赤, 青, 黃
    let colorName = ["red", "blue", "yellow"]
    let beforeMinBodySize = 0;
    let changeCircleSize = 100;
    let changeGravitySize = 100;
    let isShowStatus = false;
    let balanceGraphInterval = null;
    let cntBalanceGraph = 1;
    let MouceX = 0;
    let MouceY = 0;
    let zoomScale = 0.2;
    let cntZoomNum = 0;
    let GravityX = 0;
    let GravityY = 0;
    let BOUNCE = 0.9;
    let FRICTION = 0.1;
    let SPRINGLENGTH = circleSize*8;
    let COULOMB = 5000;
    let GRAVITY = 0.00002;
    let selectedNodes = []; //デーモンに選択されたノードのidを格納
    let nodesUndoStack = [];
    let nodesRedoStack = [];
    let edgesUndoStack = [];
    let edgesRedoStack = [];
    let selectedNodesUndoStack = [];
    let selectedNodesRedoStack = [];
    let isUndid = false;
    let functionsUndoStack = [];
    let functionsRedoStack = [];
    let graphDB = null;
    let graphStore = null;

    let visitTime = {};

    function doAtFirst(){
        beforeMinBodySize = Math.min(document.body.clientHeight,document.body.clientWidth);
        GravityX = beforeMinBodySize*3/8;
        GravityY = beforeMinBodySize*3/8;
        resizeWindow();
        initialize();
        balanceGraphInterval = setInterval(makeBalancedGraph, 50);
    }

    function initialize(){
        Nodes = [];
        Edges = [];
        selectedNodes = [];
        clickedNodeId = -1;
        lastEvent = "";
        edgeStartNodeId = -1;
        isDrawingEdge = false;
        isFinishedMove = true;
        nodeIdNow = 0;
    }

    function resizeWindow(){ // canvasのサイズを変更
        let minSize = Math.min(document.body.clientHeight,document.body.clientWidth);
        canvas.width = minSize*3/4;
        canvas.height = minSize*3/4;
        circleSize = minSize/40;
        SPRINGLENGTH = circleSize*4;
        redrawCanvas();
        beforeMinBodySize = minSize; //描画後に今のcanvasのサイズを保存
    }

    function getCanvasSize(){
        return canvas.width;
    }

    //グリッド表示
    function drawGrid(space){// sppace : 間隔
        let nowX = GravityX;
        let nowY = GravityY;
    }

    //undoStackに格納
    function pushUndoStack(){
        nodesUndoStack.unshift(getNodesCopy(Nodes));
        edgesUndoStack.unshift(getEdgesCopy(Edges));
        selectedNodesUndoStack.unshift(selectedNodes);
    }

    function popUndoStack(){
        Nodes = nodesUndoStack.shift();
        Edges = edgesUndoStack.shift();
        selectedNodes = selectedNodesUndoStack.shift();
    }

    function pushRedoStack(){
        nodesRedoStack.unshift(getNodesCopy(Nodes));
        edgesRedoStack.unshift(getEdgesCopy(Edges));
        selectedNodesRedoStack.unshift(selectedNodes);
    }

    function popRedoStack(){
        isUndid = false;
        Nodes = nodesRedoStack.shift();
        Edges = edgesRedoStack.shift();
        selectedNodes = selectedNodesRedoStack.shift();
    }

    function clearUndoStack(){
        nodesUndoStack = [];
        edgesUndoStack = [];
        selectedNodesUndoStack = [];
    }

    function clearRedoStack(){
        nodesRedoStack = [];
        edgesRedoStack = [];
        selectedNodesRedoStack = [];
    }

    function undo(){
        if(nodesUndoStack.length>0){
            isUndid = true;
            pushRedoStack();
            popUndoStack();
            redrawCanvas();
        }
    }

    function redo(){
        if(nodesRedoStack.length>0){
            pushUndoStack();
            popRedoStack();
            redrawCanvas();
        }
    }

    // データベース関連
    let request = indexedDB.open("graphDB");
    request.onupgradeneeded = function(event){ // DBがなかったとき
        graphDB = request.result;
        graphStore = graphDB.createObjectStore("graphStore", {keyPath:"graphName"});
        console.log("made db")
    }
    request.onerror = function(event){ // DBを開けなかったとき
        console.log("error");
    }
    request.onsuccess = function(event){ // DBを開けたとき
        graphDB = request.result;
        console.log("success");
        setAllSelectMenu()
    }
    function saveGraph(){
        let graphNameVal = document.getElementById("graphName").value;
        if(!graphNameVal){
            let todayDate = new Date();
            graphNameVal = "";
            graphNameVal += todayDate.getFullYear() + "-";
            graphNameVal += todayDate.getMonth() + "-";
            graphNameVal += todayDate.getDate() + "-";
            graphNameVal += todayDate.getHours() + ":";
            graphNameVal += todayDate.getMinutes() + ":";
            graphNameVal += todayDate.getSeconds() + ".";
            graphNameVal += todayDate.getMilliseconds();
        }
        // console.log(graphNameVal)
        let tx = graphDB.transaction("graphStore", "readwrite");
        graphStore = tx.objectStore("graphStore");
        graphStore.put({graphName:graphNameVal, graph:{nodes:Nodes, edges:Edges}});
        setAllSelectMenu();
        document.getElementById("graphName").value="";
    }
    function loadGraph(){
        let loadGraphName = document.getElementById('loadGraphName').value;
        let tx = graphDB.transaction("graphStore", "readwrite");
        graphStore = tx.objectStore("graphStore");
        let getRequest = graphStore.get(loadGraphName);
        getRequest.onsuccess = function(event) {
            let getResult = getRequest.result;
            if (getResult) {
                Nodes = getResult.graph.nodes;
                Edges = getResult.graph.edges;
                console.log(Nodes[0]);
            }
        };
    }
    function deleteGraph(){
        let loadGraphName = document.getElementById('loadGraphName').value;
        let tx = graphDB.transaction("graphStore", "readwrite");
        graphStore = tx.objectStore("graphStore");
        graphStore.delete(loadGraphName);
        setAllSelectMenu();
    }
    function setAllSelectMenu(){
        let tx = graphDB.transaction("graphStore", "readwrite");
        graphStore = tx.objectStore("graphStore");
        let getAllKeysRequest = graphStore.getAllKeys();
        getAllKeysRequest.onsuccess = function(){
            let allDBKeys = getAllKeysRequest.result;
            let selectElement = document.getElementById("loadGraphName");
            while(selectElement.firstChild){
                selectElement.removeChild(selectElement.firstChild);
            }
            allDBKeys.forEach(k=>{
                addSelectMenu(k);
            })
        }
    }
    function addSelectMenu(saveName){
        let addOption = document.createElement("option");
        addOption.value = saveName;
        addOption.textContent = saveName;
        document.getElementById("loadGraphName").appendChild(addOption);
    }
   
    // function saveGraph(){
    //     // saveNodesAndEdges(Nodes, Edges);
    // }
    // function loadGraph(){
    //     // loadNodesAndEdges(Nodes, Edges);
    // }



    function changeColor(){
        let clickedNodeIndex = getNodeIndex(Nodes, clickedNodeId);
        Nodes[clickedNodeIndex].c = (Nodes[clickedNodeIndex].c+1)%3 ;
    }

    function changeX(){
        let changedX = document.getElementById("changedX").value;
        let clickedNodeIndex = getNodeIndex(Nodes, clickedNodeId);
        Nodes[clickedNodeIndex].p = changedX ;
    }

    function drawNode(x, y, c, id) { //円を描写
        let canvasSize = Math.min(document.body.clientHeight,document.body.clientWidth);
        if(selectedNodes.includes(id)) {
            ctx.beginPath();
            ctx.arc(x, y, (7/5)*circleSize*changeCircleSize/100, 0, Math.PI * 2);
            ctx.fillStyle = "white";
            ctx.fill();
            ctx.strokeStyle = 'black'; 
            ctx.stroke();
            ctx.closePath();
        }
        ctx.beginPath();
        ctx.lineWidth = 2;
        if(clickedNodeId==id) {
            ctx.arc(x, y, 2*circleSize*changeCircleSize/100, 0, Math.PI * 2);
        }
        else ctx.arc(x, y, circleSize*changeCircleSize/100, 0, Math.PI * 2);
        ctx.fillStyle = colorName[c];
        ctx.fill();
        ctx.strokeStyle = 'black'; 
        ctx.stroke(); 
        ctx.lineWidth = 1;
        ctx.closePath();
    }

    function setCircleSize(){
        changeCircleSize = document.getElementById("circleSize").value;
        redrawCanvas();
    }

    function drawEdge(i, j){// idがi,jのノード間にエッジ
        let NodeI = getNodeIndex(Nodes, i);
        let NodeJ = getNodeIndex(Nodes, j);
        let xi = Nodes[NodeI].x;
        let yi = Nodes[NodeI].y;
        let xj = Nodes[NodeJ].x;
        let yj = Nodes[NodeJ].y;
        drawLine(xi, yi, xj, yj);
        // drawSquare((xi+xj)/2-5, (yi+yj)/2-5, 10);
      
    }

    function drawLine(x0, y0, x1, y1){
        ctx.beginPath();
        ctx.lineWidth = 3;
        ctx.moveTo(x0, y0);
        ctx.lineTo(x1, y1);
        ctx.strokeStyle = "gray"; 
        ctx.stroke();
        ctx.lineWidth = 1;
        ctx.closePath();
    }

    function drawSquare(x,y,width){
        ctx.beginPath();
        ctx.rect(x, y, width, width);
        ctx.strokeStyle = "black";
        ctx.stroke();
        ctx.closePath();
    }

    // Function to clear the canvas
    function clearCanvas() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
    }

    // Function to redraw all Nodes
    function redrawNodes() {
        for(let i=0;i<Nodes.length;i++){
            drawNode(Nodes[i].x, Nodes[i].y, Nodes[i].c, Nodes[i].id);
        }
        for(let i=0;i<Nodes.length;i++){
            drawNodeStatus(Nodes[i]);
        }
    }

    function redrawEdges(){
        // for(let i=0;i<Nodes.length;i++){
        //     //辺の長さを制限
        //     let neighborNodes = getNeighborNodes(Nodes[i], Nodes);
        //     neighborNodes.forEach(neighbor=>{
        //         let nowDist = Math.sqrt((Nodes[i].x-neighbor.x)**2 + (Nodes[i].y-neighbor.y)**2);
        //         if(nowDist>=SPRINGLENGTH*10){
        //             Nodes[i].x = neighbor.x + (Nodes[i].x-neighbor.x) * SPRINGLENGTH / nowDist;
        //             Nodes[i].y = neighbor.y + (Nodes[i].y-neighbor.y) * SPRINGLENGTH / nowDist;
        //         }
        //     })
        // }
        Edges.forEach(Edge => {
            drawEdge(Edge.start, Edge.end);
        });
    }

    function drawNodeStatus(node){
        let statusText = ""; // テキスト作成
        if(false) statusText += " (" + node.x + "," + node.y + ") ";
        if(isShowStatus) statusText += " id:" + node.id + " ";
        if(isShowStatus) statusText += " x:" + node.p + " ";
        if(false) statusText += " c:" + node.c + " ";

        let textMesure = ctx.measureText(statusText); //文字列の枠情報取得
        ctx.strokeStyle = "black";
        ctx.lineWidth = 1;
        ctx.fillStyle = "white";        
        ctx.fillRect(node.x, node.y, textMesure.width*2, (textMesure.actualBoundingBoxAscent+textMesure.actualBoundingBoxDescent)*2);
        ctx.strokeRect(node.x, node.y, textMesure.width*2, (textMesure.actualBoundingBoxAscent+textMesure.actualBoundingBoxDescent)*2);

        ctx.fillStyle = "black";
        ctx.textBaseline = "middle";
        ctx.fillText(statusText, node.x+textMesure.width/2, node.y+textMesure.actualBoundingBoxAscent+(textMesure.actualBoundingBoxAscent+textMesure.actualBoundingBoxDescent)/2);
     }

     function showStatus(){
        isShowStatus = !isShowStatus;
        if(isShowStatus)redrawNodes(Nodes);
     }

     function showProcessLog(beforeNodes, nowNodes){
        let showText = "";
        beforeNodes.forEach((beforeNode,i)=>{
            let nowNode = nowNodes[i];
            if(selectedNodes.includes(beforeNode.id)){
                if(beforeNode.id != nowNode.id) return null;
                showText += beforeNode.id + " : ";
                if(beforeNode.p==nowNode.p && beforeNode.c==nowNode.c) showText += "not changed\n";
                else if(beforeNode.p!=nowNode.p && beforeNode.c==nowNode.c) showText += "x:" + beforeNode.p + " → x:" + nowNode.p + "\n";
                else if(beforeNode.p==nowNode.p && beforeNode.c!=nowNode.c) showText += "c:" + beforeNode.c + " → c:" + nowNode.c + "\n";
            }
        })
        document.getElementById("processArea").textContent = showText;
     }

    function redrawCanvas(){
        // ノード座標の更新
        let nowMinBodySize = Math.min(document.body.clientHeight,document.body.clientWidth);
        for(let i=0;i<Nodes.length;i++){
            Nodes[i].x = Nodes[i].x * nowMinBodySize / beforeMinBodySize;
            Nodes[i].y = Nodes[i].y * nowMinBodySize / beforeMinBodySize;
        }
        // 中心座標の更新
        GravityX = GravityX * nowMinBodySize / beforeMinBodySize;
        GravityY = GravityY * nowMinBodySize / beforeMinBodySize;

        clearCanvas();
        redrawEdges();
        redrawNodes();
    }

    function setGravitySize(){
        changeGravitySize = document.getElementById("gravitySize").value;
        redrawCanvas();
    }

    function switchMakeBlancedGraph(){
        if(cntBalanceGraph%2 == 0) balanceGraphInterval = setInterval(makeBalancedGraph, 1);
        else clearInterval(balanceGraphInterval);
        makeNotCactusGraph = ++cntBalanceGraph%2;
    }

    function makeBalancedGraph(){
        for(let i=0;i<Nodes.length;i++){
            if(Nodes[i].id!=clickedNodeId){
                let fx = 0;
                let fy = 0;
                Nodes.forEach(colombedNode=>{
                    if(colombedNode.id!=Nodes[i].id){
                        let dstX = Nodes[i].x - colombedNode.x ;
                        let dstY = Nodes[i].y - colombedNode.y;
                        let dstSQRT = Math.sqrt(dstX * dstX + dstY * dstY);
                        let f = COULOMB/(dstSQRT*dstSQRT) //クーロン力
                        if(dstSQRT==0) dstSQRT = 0.5;
                        fx += f * dstX/dstSQRT;
                        fy += f * dstY/dstSQRT;
                    }
                })
                if(isNaN(fx)) fx = 0;
                if(isNaN(fy)) fy = 0;

                Nodes.forEach(frictionedNode=>{
                    if(frictionedNode.id!=Nodes[i].id && isNeighbor(frictionedNode, Nodes[i])){
                        let dstX = frictionedNode.x - Nodes[i].x;
                        let dstY = frictionedNode.y - Nodes[i].y;
                        let dstSQRT = Math.sqrt(dstX * dstX + dstY * dstY);
                        let f = BOUNCE * (dstSQRT - SPRINGLENGTH); //フックの法則による力
                        if(dstSQRT==0) dstSQRT = 0.5;
                        fx += f * dstX/dstSQRT;
                        fy += f * dstY/dstSQRT;
                    }
                })

                // if(isNaN(fx)) fx = 0;
                // if(isNaN(fy)) fy = 0;

                let gDstX =  Nodes[i].x-GravityX;
                let gDstY =  Nodes[i].y-GravityY;
                let gDst = Math.sqrt(gDstX*gDstX + gDstY*gDstY);
                let gF = -1 * (GRAVITY * changeGravitySize/100) * (gDst*gDst);
                fx += gF * gDstX/gDst;
                fy += gF * gDstY/gDst;

                Nodes[i].vx = (Nodes[i].vx + fx) * FRICTION; //摩擦
                Nodes[i].vy = (Nodes[i].vy + fy) * FRICTION; //摩擦

                Nodes[i].x += Nodes[i].vx;
                Nodes[i].y += Nodes[i].vy;
            }
        }
        redrawCanvas();
    }

    function doZoom(event){
        const rect = canvas.getBoundingClientRect();
        const x = event.clientX - rect.left;
        const y = event.clientY - rect.top;
        //ノード座標の変更 図形の合同条件を思い出せ
        if(event.wheelDelta>0 && cntZoomNum<=5){
            cntZoomNum++;
            for(let i=0;i<Nodes.length;i++){
                Nodes[i].x += (Nodes[i].x - x) * zoomScale;
                Nodes[i].y += (Nodes[i].y - y) * zoomScale;
            }
            circleSize += circleSize*zoomScale;
            COULOMB = COULOMB * ((1+zoomScale)**2);
            GRAVITY = GRAVITY /  (1+zoomScale)**2;
        }else if(event.wheelDelta<0 && cntZoomNum>=-5){
            cntZoomNum--;
            for(let i=0;i<Nodes.length;i++){
                Nodes[i].x -= (Nodes[i].x - x) * zoomScale / (1+zoomScale);
                Nodes[i].y -= (Nodes[i].y - y) * zoomScale / (1+zoomScale);
            }
            circleSize -= circleSize * zoomScale / (1+zoomScale);
            COULOMB = COULOMB * ((1 / (1+zoomScale))**2);
            GRAVITY = GRAVITY /  (1 / (1+zoomScale))**2;
        }
    
        //エッジの長さ上限変更
        SPRINGLENGTH = circleSize * 4;
        //ノード大きさの変更
        //係数の変更   
        redrawCanvas();
    }

    function isNeighbor(node1, node2){
        for(let i=0;i<Edges.length;i++){
            if((Edges[i].start == node1.id && Edges[i].end   == node2.id)||
               (Edges[i].end   == node1.id && Edges[i].start == node2.id)) return true;
        }
        return false;
    }

    function removeEdgesById(edges, id){
        // return array.filter(function(element){
        //     return (element.start != id && element.end != id);
        // });
        let resEdges = [];
        edges.forEach(edge=>{
            if(edge.start!=id&&edge.end!=id){
                resEdges.push(getEdgeCopy(edge));
            }
        })
        return resEdges;
    }

    function getNodeIndex(nodes, id) {
        let index = nodes.findIndex(node => node.id == id);
        return index !== -1 ? index : -1;
    }

    function handleMouseDown(event){
        clickedNodeId = -1;
        const rect = canvas.getBoundingClientRect();
        const x = event.clientX - rect.left;
        const y = event.clientY - rect.top;
        MouceX = x; //クリック時のマウス座標
        MouceY = y; //クリック時のマウス座標
        Nodes.forEach(Node => {
            const dx = x - Node.x;
            const dy = y - Node.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            if (distance < circleSize) {
                clickedNodeId = Node.id;
            }
        });

        lastEvent = "mousedown";
    }

    function handleMouseUp(event){
        clickedNodeId = -1;

        lastEvent = "mouseup";
    }

    function handleClick(event){
        if(isFinishedMove){
            const rect = canvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;

            clickedNodeId = -1;
            Nodes.forEach(Node => {
                const dx = x - Node.x;
                const dy = y - Node.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                if (distance < circleSize) {
                    clickedNodeId = Node.id;
                }
            });
            if(clickedNodeId !== -1){ //ノードがクリックされた場合
                if(!isDrawingEdge){ //エッジの始点になりうる
                    edgeStartNodeId = clickedNodeId;
                    isDrawingEdge = true;
                }else{ //エッジの終点になりうる
                    if(edgeStartNodeId !== clickedNodeId){ //エッジ追加
                        if(isUndid) clearRedoStack();
                        pushUndoStack(); //前の状態保存
                        let edgeIndex = findEdgeIndex(edgeStartNodeId, clickedNodeId);
                        if(edgeIndex!=-1){ //エッジが既に存在するなら
                            Edges.splice(edgeIndex,1);
                        }else{ //エッジがまだ存在しないなら
                            Edges.push({start: edgeStartNodeId, end: clickedNodeId});
                        }
                        clickedNodeId = -1;
                    }
                    isDrawingEdge = false;
                }
                // clickedNodeId = -1;
            }
        }
        isFinishedMove = true;
        redrawCanvas();
    }

    function findEdgeIndex(edgeStartNodeId, clickedNodeId) {
        // エッジを探索するために Edges 配列をループする
        for (let i = 0; i < Edges.length; i++) {
            let edge = Edges[i];
            // エッジが既に存在するかどうかを確認
            if (
                (edge.start === edgeStartNodeId && edge.end === clickedNodeId) ||
                (edge.start === clickedNodeId && edge.end === edgeStartNodeId)
            ) {
                return i; // エッジが存在する場合はそのインデックスを返す
            }
        }
        return -1; // エッジが存在しない場合は -1 を返す
    }   

    // Function to handle mouse click
    function handleDoubleClick(event) {
        if(isUndid) clearRedoStack();
        pushUndoStack(); //前の状態保存

        const rect = canvas.getBoundingClientRect();
        const x = event.clientX - rect.left;
        const y = event.clientY - rect.top;

        clickedNodeId = -1;
        Nodes.forEach(Node=> {
            const dx = x - Node.x;
            const dy = y - Node.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            if (distance < circleSize) {
                clickedNodeId = Node.id;
            }
        });

        if (clickedNodeId !== -1) { //ノードがクリックされた場合
            Nodes.splice(getNodeIndex(Nodes, clickedNodeId), 1); // Remove the clicked Node
            Edges = removeEdgesById(Edges, clickedNodeId);
            clickedNodeId = -1;
            isDrawingEdge = false;
        } else {
            Nodes.push(new Node(x, y, nodeIdNow++, getRandomX(), 0, 0, 0)); // Add a new Node
        }

        redrawCanvas();
    }

    function getRandomX(){
        let xRange = document.getElementById("xRange").value;
        return Math.floor(Math.random()*xRange);
    }

    // Function to handle mouse drag
    function handleDrag(event) {
        if(event.buttons == 1){
            isFinishedMove = false;
            const rect = canvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;
            // Find the Node being dragged
            if (clickedNodeId!==-1) {
                let Node = Nodes[getNodeIndex(Nodes, clickedNodeId)];
                Node.x = x;
                Node.y = y;
            }else if(clickedNodeId===-1){
                for(let i=0;i<Nodes.length;i++){
                    Nodes[i].x += x-MouceX;
                    Nodes[i].y += y-MouceY;
                }
                GravityX += x-MouceX;
                GravityY += y-MouceY;
                MouceX = x;
                MouceY = y;
            }
            redrawCanvas();
        }
        
    }


    // Event listeners
    canvas.addEventListener('mousedown', handleMouseDown);
    canvas.addEventListener('mouseup', handleMouseUp);
    canvas.addEventListener('click', handleClick);
    canvas.addEventListener('dblclick', handleDoubleClick);
    canvas.addEventListener('mousemove', handleDrag);
    canvas.addEventListener("mousewheel", doZoom);
    window.addEventListener("DOMContentLoaded", doAtFirst);
    window.addEventListener("resize", resizeWindow);
    let setCircleSizeSlider = document.getElementById("circleSize");
    setCircleSizeSlider.addEventListener("input", setCircleSize);
    let setGravitySizeSlider = document.getElementById("gravitySize");
    setGravitySizeSlider.addEventListener("input", setGravitySize);

    // make graph
    function redrawRandomCactusGraph(){
        if(isUndid) clearRedoStack();
        pushUndoStack(); //前の状態保存
        initialize();
        makeRandomCactusGraph();
        clearCanvas();
        redrawCanvas();
    }

    function redrawRandomUnCactusGraph(){
        if(isUndid) clearRedoStack();
        pushUndoStack(); //前の状態保存
        initialize();
        makeRandomUnCactusGraph();
        clearCanvas();
        redrawCanvas();
    }

    function makeRandomCactusGraph(){// w回c個から成る部分グラフ生成
        let graphSize = document.getElementById("graphSize").value;
        let graphComplex = document.getElementById("graphComplex").value;
        Nodes = [];
        Edges = [];
       
        let camvasSize = getCanvasSize();
        let beginNode = new Node(Math.random()*camvasSize, Math.random()*camvasSize, nodeIdNow++, getRandomX(), 0, 0, 0); //開始ノード作成
        Nodes.push(beginNode);//ノードとして登録
        for(let i=0;i<graphSize;i++){
            let nowNode = Nodes[Math.floor(Math.random()*Nodes.length)];//ノード選択
            makeRandomGraph(nowNode, graphComplex);
        }
    }

    function makeRandomUnCactusGraph(){
        let graphSize = document.getElementById("graphSize").value;
        let graphComplex = document.getElementById("graphComplex").value;
        Nodes = [];
        Edges = [];
       
        let camvasSize = getCanvasSize();
        let beginNode = getRandomNode();
        Nodes.push(beginNode);//ノードとして登録
        makeRandomCycle(beginNode, Math.floor(Math.random()*(graphComplex-3)+3)); //3以上graphComplex以下の長さの閉路作成
        let randomNodeIndex1 = Math.floor(Math.random()*Nodes.length);
        let randomNodeIndex2 = Math.floor(Math.random()*Nodes.length);
        if(randomNodeIndex1==randomNodeIndex2) randomNodeIndex2 = (randomNodeIndex1+1)%Nodes.length;
        makeRandomCycleFromPath(Nodes[randomNodeIndex1], Nodes[randomNodeIndex2], graphComplex); //閉路から閉路を生やす
        for(let i=0;i<graphSize;i++){
            let nowNode = Nodes[Math.floor(Math.random()*Nodes.length)];//ノード選択
            makeRandomGraph(nowNode, graphComplex);
        }
    }

    function makeRandomCycleFromPath(node1, node2, cycleLength){
       
        let nextNode = node1;
        let cnt = 0;
        let randomCycleLength = Math.floor(Math.random()*(cycleLength-3)+3);
        do{
            let parentNode = nextNode;//最後のノードを取得
            let childNode = getRandomNode(); 
            Nodes.push(childNode);
            Edges.push({start: parentNode.id, end: childNode.id});
            nextNode = childNode;//最後のノード更新
            cnt += 1;
        }while(cnt<randomCycleLength);
        Edges.push({start: nextNode.id, end: node2.id});
    }

    function makeNotCactusGraph(beginNode, c){ //２つの閉路がくっついた形のグラフを一つ作る
        makeRandomCycle(beginNode, c); //閉路を１つ生成
        
        if(randomNodeIndex1==randomNodeIndex2) randomNodeIndex2 = (randomNodeIndex1+1)%Nodes.length;
        let onCycleNode1 = Nodes[randomNodeIndex1];
        let onCycleNode2 = Nodes[randomNodeIndex2];
        
    }

    function makeRandomGraph(nowNode, c){
        if(Math.random()>0.5){
            makeRandomCycle(nowNode, c);
        }else{
            makeRandomTree(nowNode, c);
        }
    }

    function makeRandomTree(rootNode, pathLength){//rootNodeを根, ノード数c
        let treeNodes = [];
        treeNodes.push(rootNode);
        let cnt = 0;
        let randomPathLength = Math.floor(Math.random()*(pathLength-2)+2);
        do{
            let parentNode = treeNodes[Math.floor(Math.random()*treeNodes.length)]; //親取得
            let childNodes = [];
            let childrenSize = Math.floor(Math.random()*randomPathLength); //子の数決定
            for(let i=0;i<childrenSize;i++){
                let childNode = getRandomNode();//子生成
                // childNode.x = parentNode.x + Math.floor(Math.random()*circleSize*8)-circleSize*4;
                // childNode.y = parentNode.y + Math.floor(Math.random()*circleSize*8)-circleSize*4;
                Nodes.push(childNode);//子をノードとして登録
                Edges.push({start: parentNode.id, end: childNode.id});//エッジ作成
                treeNodes.push(childNode);
                cnt += 1;
            }
        }while(cnt<randomPathLength);
    }

    function makeRandomCycle(rootNode, cycleLength){
        let nextNode = rootNode;
        let cnt = 0;
        let randomCycleLength = Math.floor(Math.random()*(cycleLength-3)+3);
        do{
            let parentNode = nextNode;//最後のノードを取得
            let childNode = getRandomNode(); 
            // childNode.x = parentNode.x + Math.floor(Math.random()*circleSize*8)-circleSize*4;
            // childNode.y = parentNode.y + Math.floor(Math.random()*circleSize*8)-circleSize*4;
            Nodes.push(childNode);
            Edges.push({start: parentNode.id, end: childNode.id});
            nextNode = childNode;//最後のノード更新
            cnt += 1;
        }while(cnt<randomCycleLength);
        Edges.push({start: nextNode.id, end: rootNode.id});
    }

    function getRandomNode(){
        let camvasSize = getCanvasSize();
        return new Node(Math.random()*camvasSize, Math.random()*camvasSize, nodeIdNow++, getRandomX(), getRandomColor(), 0, 0);
    }

    function getRandomColor(){
        return Math.floor(Math.random()*3);
    }

    function isIdInNodes(nodes, id){
        let isIn = false;
        nodes.forEach(node=>{
            if(node.id===id) isIn = true;
        })
        return isIn;
    }

    // 前処理
    let minNodes = [];
    let minEdges = [];
    function doMinimizeOnIsCactusGraph(){
        minNodes = getNodesCopy(Nodes);
        minEdges = getEdgesCopy(Edges);
        deleteLeavesMinNodesEdges(); // 次数1以下のノードを削除
        deleteEdgesOnCycle(); // 閉路をなるべく小さくする
    }

    function redrawMinimumGraph(){
        doMinimizeOnIsCactusGraph();
        Nodes = getNodesCopy(minNodes);
        Edges = getEdgesCopy(minEdges);
        redrawCanvas();
    }

    function deleteEdgesOnCycle(){ // 閉路をなるべく小さくする 次数2かつ各隣接ノードが隣接していないなら削除
        let deleteNodeIds = [];
        for(let i=0;i<minNodes.length;i++){ //ノードを順番に参照
            let cnt=0;
            let isFind = false;
            let nodeId1 = -1;
            let nodeId2 = -1;
            minEdges.forEach(edge=>{
                if(edge.start==minNodes[i].id){ //エッジの片方が一致するなら
                    if(cnt==0)nodeId1 = edge.end;
                    else nodeId2 = edge.end;
                    cnt++;
                }else if(edge.end==minNodes[i].id){ //エッジの片方が一致するなら
                    if(cnt==0) nodeId1 = edge.start;
                    else nodeId2 = edge.start;
                    cnt++;
                }
            })
            if(cnt==2){ // 次数が2ならば
                let isTriangle = false;
                for(let j=0;j<minEdges.length;j++){//三角形を成すか判定
                    if((minEdges[j].start==nodeId1&&minEdges[j].end==nodeId2)||(minEdges[j].start==nodeId2&&minEdges[j].end==nodeId1)) { //nodeとnodeId1とnodeId2で三角形を成すならば
                       
                        isTriangle = true;
                        break; //三角形ならば次のノードへ
                    }
                }
                if(!isTriangle){//三角形でないならば

                    


                    minEdges = removeEdgesById(minEdges, minNodes[i].id);//削除処理
                    minNodes.splice(getNodeIndex(minNodes, minNodes[i].id), 1);//削除処理
                    minEdges.push({start:nodeId1, end:nodeId2});//エッジ追加
                    isFind = true;

                }
            }
            if(isFind){//削除が行われたならば
                deleteEdgesOnCycle();//削除後のグラフに対して削除処理
                break;
            }
        }
    }

    function deleteLeavesMinNodesEdges(){ //次数1以下のノードを削除
        let isContinueDelete = false;
        let deleteNodeIds = [];
        if(minNodes.length>2){
            minNodes.forEach((node,i)=>{
                let cnt = 0;
                minEdges.forEach(edge=>{
                    if(edge.start==node.id || edge.end==node.id) cnt++;
                })
                if(cnt<=1) {
                    isContinueDelete = true;
                    deleteNodeIds.push(node.id);
                }
            })
            deleteNodeIds.forEach(nodeId=>{
                minNodes.splice(getNodeIndex(minNodes, nodeId), 1);
                minEdges = removeEdgesById(minEdges, nodeId);
            });
            if(isContinueDelete) deleteLeavesMinNodesEdges();
        }
    }

    // cactus check
    function doTestCheckCactusGraph(){
        do{
            redrawRandomCactusGraph();
            doCheckCactusGraph();
            if(!isCactus)break;
        }while(true);
    }

    function doTestCheckUnCactusGraph(){
        do{
            redrawRandomUnCactusGraph();
            doCheckCactusGraph();
            if(isCactus)break;
        }while(true);
    }

    let originNodes = [];
    let originEdges = [];
    function doCheckCactusGraph(){
        doMinimizeOnIsCactusGraph();
        
        originNodes = getNodesCopy(Nodes);
        originEdges = getEdgesCopy(Edges);
        Nodes = getNodesCopy(minNodes);
        Edges = getEdgesCopy(minEdges);

        isCycle = false;
        isCactus = true;
        separatedGraphs = [getNodesCopy(Nodes)];
        isCactusGraph(Nodes);
        if(isCactus)console.log("yes cactus");
        else console.log("no cactus");

        Nodes = getNodesCopy(originNodes);
        Edges = getEdgesCopy(originEdges);
        redrawCanvas();
    }

    let separatedGraphs = [];
    let lastSeparatedGraphs = [];
    let jointNodes = [] //関節点を格納
    let isCactus = true;
    function isCactusGraph(nodes){ //全ての関節点を取得し, 各関節点除去時に, 3なら非カクタス, 2なら閉路判定, 1ならパス
        //まず関節点配列の作成
        makeJointNodes(nodes);
        //各関節点に対して処理
        for(let jointNodeIndex=0;jointNodeIndex<jointNodes.length;jointNodeIndex++){
            let nowJointNode = jointNodes[jointNodeIndex] //処理を行う関節点
            //関節点を削除して分割されたグラフと削除されたエッジの数とエッジが削除されたノードを取得
            let jointNodeDeletedNodes = getNodeDeletedNodes(nodes, nowJointNode);//関節点を削除したノード配列
            makeSeparatedNodes(jointNodeDeletedNodes) //分割されたグラフを作成
            //各グラフに対して, 消えたエッジの数に応じた処理を実行
            for(let separatedGraphIndex=0;separatedGraphIndex<separatedGraphs.length;separatedGraphIndex++){//各グラフに対して
                let deletedEdgeNum = getDeletedEdgeNum(separatedGraphs[separatedGraphIndex], nodes); //グラフからエッジが何本消えたか
                if(deletedEdgeNum>=3) { // 消えたエッジが3本以上の時
                    isCactus = false;
                }else if(deletedEdgeNum===2){ //消えたエッジが2本の時
                    let edgeDeletedNodes = getEdgeDeleted2NodeIds(separatedGraphs[separatedGraphIndex], nodes);
                    visitedIsConnected1 = [];
                    visitedIsConnected2 = [];
                    separatedGraphs[separatedGraphIndex].forEach(node=>{visitedIsConnected1.push(false);visitedIsConnected2.push(false);});
                    getPathFromNodeToNode(edgeDeletedNodes[0], edgeDeletedNodes[1], separatedGraphs[separatedGraphIndex]);
                    if(separatedGraphs[separatedGraphIndex].length>2){
                        for(let searchPathStackIndex1=0;searchPathStackIndex1<searchPathStack.length-1;searchPathStackIndex1++){
                            for(let searchPathStackIndex2=searchPathStackIndex1+1;searchPathStackIndex2<searchPathStack.length;searchPathStackIndex2++){
                                isCycle = false;
                                connectedDfs(searchPathStack[searchPathStackIndex1], 
                                        separatedGraphs[separatedGraphIndex], 
                                        -1, 
                                        1, 
                                        [searchPathStack[searchPathStackIndex1], searchPathStack[searchPathStackIndex2]]);
                                if(isCycle) {
                                    isCactus = false;
                                    break;
                                }
                            }
                            if(isCycle){
                                break;
                            }
                        }
                    }
                }
                if(!isCactus){
                    break;
                }
            }
            if(!isCactus){
                break;
            }
        }
    }



    let isVisited = []; //再帰で参照し続けるのでグローバル dfs
    let lowArray = []; //再帰で参照し続けるのでグローバル dfs
    let ordArray = []; //再帰で参照し続けるのでグローバル dfs
    let ordNum = 1; //再帰で参照し続けるのでグローバル dfs
    let dfsTree = []; //{parent:id, children:[id1, ... idk]} dfs木を隣接リストで作る
    function makeJointNodes(nodes){ //nodesの関節点を作成
        isVisited = [];
        lowArray = [];
        ordArray = [];
        nodes.forEach(node=>{
            isVisited.push(false);
            lowArray.push(-1);
            ordArray.push(-1);
            dfsTree.push({parent:node.id, children:[]});
        });
        ordNum = 1;
        //ord, low, dfsTreeを作成
        makeOrdAndLowDfs(nodes, nodes[0], nodes[0]);
        isVisited = [];
        nodes.forEach(node=>{isVisited.push(false)});
       
        //関節点の配列を作成
        makeJointNodesDfs(nodes, nodes[0], true);
    }

    function makeJointNodesDfs(nodes, visitingNode, isStart){//jointNodesに関節点を格納
        let visitingNodeIndex = getNodeIndex(nodes, visitingNode.id); //nodes上のインデックス取得
        isVisited[visitingNodeIndex] = true; //訪問済にする
        let neighborNodes = getNeighborNodes(visitingNode, nodes); //隣接ノードを取得
        if(isStart){//ルートの時
            // if(neighborNodes.length>=2) jointNodes.push(visitingNode); //子が2つ以上なら関節点
        }
        neighborNodes.forEach(neighborNode=>{//各隣接ノードに対して
            let neighborIndex = getNodeIndex(nodes, neighborNode.id); //隣接ノードのインデックス
            if(ordArray[visitingNodeIndex]<=lowArray[neighborIndex] && !isIdInNodes(jointNodes, visitingNode.id)) jointNodes.push(visitingNode); //関節点か確認
            if(!isVisited[neighborIndex]){ //未訪問ならば
                makeJointNodesDfs(nodes, neighborNode, false);
            }
        })
    }

    function makeOrdAndLowDfs(nodes, visitingNode, beforeNode){  //ord, low, dfsTreeを作成
        isVisited[getNodeIndex(nodes, visitingNode.id)] = true;
        // 訪問時操作開始
        let visitingIndex = getNodeIndex(nodes, visitingNode.id);
        ordArray[visitingIndex] = ordNum;
        lowArray[visitingIndex] = ordNum;
        ordNum += 1;
        // 訪問時操作終了
        let neighborNodes = getNodeDeletedNodes(getNeighborNodes(visitingNode, nodes), beforeNode);
        neighborNodes.forEach(node => {
            let nextIndex = getNodeIndex(nodes, node.id);
            if(!isVisited[nextIndex] && nextIndex!==-1) {
                dfsTree.forEach((t,i)=>{if(t.parent==visitingNode.id)dfsTree[i].children.push(node.id);});
                dfs(nodes, node, visitingNode);
                if(lowArray[visitingIndex] > lowArray[nextIndex]) lowArray[visitingIndex] = lowArray[nextIndex];
            } else { //行こうとした先が訪問済だった時
                if(lowArray[visitingIndex]>ordArray[nextIndex]) lowArray[visitingIndex] = ordArray[nextIndex];
            }
        })
    }

    let searchPathStack = []; //パスを格納
    let visitedSearchPathQueue = [];
    let prevNodes = []; // 経路復元に使う
    function getPathFromNodeToNode(startNode, goalNode, graph){// searchPathStackにパスを記録
        searchPathStack = [];
        pathStack = [];
        visitedSearchPath = [];
        visitedSearchPathQueue = [];
        prevNodes = [];
        graph.forEach(graph=>{prevNodes.push(-2)});
        prevNodes[getNodeIndex(graph, startNode.id)] = -1; 
        visitedSearchPathQueue.push(startNode);
        isFindPath = false;
    
        searchPathBfs(startNode, graph, goalNode);
        
        restoreBfsPath(graph, goalNode);
    }

    function restoreBfsPath(graph, goalNode){
        let nowNodeIndex = getNodeIndex(graph, goalNode.id); 
        do{
            searchPathStack.push(graph[nowNodeIndex].id);
            if(prevNodes[nowNodeIndex]==-1) break;
            nowNodeIndex = prevNodes[nowNodeIndex];
        }while(true)
    }

    let isFindPath = false;
    function searchPathBfs(visitingNode, graph, goalNode){ //BFSにより最短パスを探索
        let visitingNodeId = visitingNode.id;
        let visitingNodeIndex = getNodeIndex(graph, visitingNodeId);
        visitedSearchPath[visitingNodeIndex] = true;
        do{
            let nowNode = visitedSearchPathQueue.shift();
            let neighborNodes = getNeighborNodes(nowNode, graph);
            neighborNodes.forEach(node=>{
                let nextNodeIndex = getNodeIndex(graph, node.id);
                if(prevNodes[nextNodeIndex]>=-1){

                }else{
                    prevNodes[nextNodeIndex] = getNodeIndex(graph, nowNode.id);
                    visitedSearchPathQueue.push(node);
                }
            })
        }while(visitedSearchPathQueue.length>0)
    }

    function getEdgeDeleted2NodeIds(nowGraph, lastGraph){
        let resNodes = [];
        nowGraph.forEach(node=>{
            Edges.forEach(edge=>{
                if(node.id==edge.start){ //今のグラフ上のあるノードとエッジの始点が一致したなら
                    if(isIdInNodes(lastGraph, edge.end) && !isIdInNodes(nowGraph, edge.end)){//前のグラフにあって今のグラフにないノードならば関節点であるため
                        resNodes.push(nowGraph[getNodeIndex(nowGraph,edge.start)].deepCopy());
                    }
                }else if(node.id==edge.end){
                    if(isIdInNodes(lastGraph, edge.start) && !isIdInNodes(nowGraph, edge.start)){//前のグラフにあって今のグラフにないノードならば
                        resNodes.push(nowGraph[getNodeIndex(nowGraph,edge.end)].deepCopy());
                    }
                }
            })
        })
        return resNodes;
    }

    function getAddedNodes(nodes1, nodes2){
        node2.forEach(node=>{ //既にないなら追加
            if(!isIdInNodes(nodes1, node.id)) nodes1.push(node);
        })
        return nodes1;
    }

    function getSubtractedNodes(nodes1, nodes2){
        node2.forEach(node=>{ //既にあるなら削除
            if(isIdInNodes(nodes1, node.id)) nodes1.splice(getNodeIndex(nodes1, node.id),1);
        })
        return nodes1;
    }
    
    let visitedIsConnected1 = []; 
    let isCycle = false;
    //separatedGraphs[i]-searchPathStack+searchPathStack[j]+searchPathStack[j]の中でsearchPathStack[j]からsearchPathStack[j]に到達できるか
    function connectedDfs(nodeId, graph, beforeNodeId, visitNum, nodesInCycle){ 
        let visitingIndex = getNodeIndex(graph, nodeId);
        visitedIsConnected1[visitingIndex] = true;
       
        let childNodes = getNeighborNodes(graph[visitingIndex], graph);
        if(visitNum>=2) childNodes = getNodeDeletedNodes(childNodes, graph[getNodeIndex(graph, beforeNodeId)]);
        let teststr = "childs:[";
        childNodes.forEach(node=>{
            teststr+=node.id+" ";
        })
        
        childNodes.forEach(node=>{
            if((!searchPathStack.includes(nodeId)&&searchPathStack.includes(node.id)) || (searchPathStack.includes(nodeId)&&!searchPathStack.includes(node.id))||(!searchPathStack.includes(nodeId)&&!searchPathStack.includes(node.id))){ //スタートの隣のゴールではない
                
                if(!visitedIsConnected1[getNodeIndex(graph, node.id)] //未訪問である
                    && node.id!=beforeNodeId  //親ノードではない
                    && (!searchPathStack.includes(node.id))) { //サーチパスにない
                    //子供を訪問 親には訪問しない
                   
                    connectedDfs(node.id, graph, nodeId, visitNum+1, nodesInCycle);
                } else if(searchPathStack.includes(node.id)
                    && node.id!=nodesInCycle[0] //ゴールである 
                    && node.id!=beforeNodeId) { //親ノードではない
               
                    isCycle=true;
                }
            }
        })
    }

    function getDeletedEdgeNum(nowNodes, lastNodes){//分離前(直前)のグラフと比較
        let cnt = 0;
        nowNodes.forEach(node=>{//部分グラフの各ノードについて
            Edges.forEach(edge=>{
                if(node.id===edge.start){
                    if(isIdInNodes(lastNodes, edge.end) && !isIdInNodes(nowNodes, edge.end)) {
                        cnt++;
                    }
                }else if(node.id===edge.end){
                    if(isIdInNodes(lastNodes, edge.start) && !isIdInNodes(nowNodes, edge.start)) {
                        cnt++;
                    }
                }
            })
        })
        return cnt;
    }

    function getLastGraph(node){
        let resGraph = [];
        lastSeparatedGraphs.forEach(graph=>{
            if(isIdInNodes(graph, node.id)){
                resGraph = getNodesCopy(graph);
            }
        })
        return resGraph;
    }

    
    // let separatedGraphs = [];// 分割結果を格納する
    let deletedNodes = []; //ノードを削除したあとのノード集合
    function getSeparatedGraphs(nodes){//nodesの関節点を削除し, node配列の配列を返す 
        separatedGraphs = [];// 分割結果を格納するので初期化
        deletedNodes = getNodesCopy(nodes); //削除処理用のノード配列を作成
        isVisited = []; //初期化
        lowArray = [];
        ordArray = [];
        ordNum = 1;
        dfsTree = [];
        nodes.forEach(node=>{
            isVisited.push(false);
            lowArray.push(-1);
            ordArray.push(-1);
            dfsTree.push({parent:node.id, children:[]});
        });
        let beginNode = nodes[0]; //dfsを開始するノード
        dfs(nodes, beginNode, beginNode); //dfs木, low, ordを作成 再帰です
        // 今から, dfs木を辿って関節点を探します. dfsTree上で全ての関節点を削除します.
        isVisited.forEach((n,i)=>{ //今からまた使うので初期化
            isVisited[i] = false;
        })
        deleteDfs(nodes, beginNode.id, true); //deletedNodesに関節点を除いたノード集合を格納
        
        makeSeparatedNodes(); // separatedGraphsに分割されたグラフを格納
        return separatedGraphs;
    }

    function makeSeparatedNodes(nodes){ //nodesを分割してseparatedGraphsに格納
        separatedGraphs = []//初期化
        isVisited = [];// 初期化
        nodes.forEach(node=>{isVisited.push(false);})
        let beginNode = nodes[0];
        nodes.forEach((node,i)=>{
            if(!isVisited[i]) {
                separatedGraphs.push([]); //このグラフを記録する配列を追加
                unionDfs(nodes, node); //訪問済で無ければDFS
            }
        })
    }

    function unionDfs(nodes, visitingNode){
        visitingIndex = getNodeIndex(nodes, visitingNode.id); //訪問しているノード
        isVisited[visitingIndex] = true; //訪問済にする
        separatedGraphs[separatedGraphs.length-1].push(visitingNode); //分割されたグラフの一部として登録
        let childNodes = getNeighborNodes(visitingNode, nodes); //隣接ノードを取得
        childNodes.forEach(node=>{ //隣接ノード一つずつに対して処理
            let childIdIndex = getNodeIndex(nodes, node.id);
            if(!isVisited[childIdIndex] && childIdIndex!==-1){
                unionDfs(nodes, node);
            }
        })
    }

    

    let beforeDeletedNodes = [];
    let isDeleted = false;
    function deleteDfs(nodes, visitingId, isStart){ //nodesからvisitingIdを消せるなら消す
        if(isStart){
            beforeDeletedNodes = getNodesCopy(nodes);
            isDeleted = false;
        }
        if(nodes.length==1) return;
        visitingIndex = getNodeIndex(nodes, visitingId); //Nodes上のインデックス
        isVisited[visitingIndex] = true; //isVisitedはNodesに対応
        let childIds = getDfsTreeChildren(visitingIndex); //DFStree上の子ノード達を取得
        let isExist = false;
        childIds.forEach(childId => {// 各子どもたちに対して
            let nextIndex = getNodeIndex(nodes, childId); //Nodes上のインデックス
            if(!isStart && ordArray[visitingIndex]<=lowArray[nextIndex] &&  isIdInNodes(deletedNodes,visitingId)) {
                isExist = true;
            }
            if(!isVisited[nextIndex] && !isDeleted) deleteDfs(nodes, childId, false);
        })

        // 削除処理開始
        if(!isDeleted){
            if(isExist || (isStart&&childIds.length>=2)) {
                deletedNodes.splice(getNodeIndex(deletedNodes, visitingId),1);//削除処理
                isDeleted = true;
            }
            if(isStart && childIds.length<2){
                if(beforeDeletedNodes.length==nodes.length) {//関節点がない場合は次数最大の点を消す
                    deletedNodes.splice(getNodeIndex(deletedNodes, getMaxDegreeId(nodes)),1); //削除処理
                    isDeleted = true;
                }
            }
        }
        //削除処理終了
    }


    function getMaxDegreeId(nodes){ // nodes内の最大次数のノードのidを返す
        let maxDegreeId = -1;
        let maxDegree = -1;
        nodes.forEach(node=>{
            let nowDegree = 0;
            Edges.forEach(edge=>{
                if(node.id==edge.start && isIdInNodes(nodes, edge.end)){
                    nowDegree++;
                }else if(node.id==edge.end && isIdInNodes(nodes, edge.start)){
                    nowDegree++;
                }
            })
            if(nowDegree>maxDegree) maxDegreeId = node.id;
        })
        return maxDegreeId;
    }

    function getDfsTreeChildren(parentId){
        for(let i=0;i<dfsTree.length;i++){
            if(parentId == dfsTree[i].parent) return dfsTree[i].children;
        }
        return dfsTree;
    }

    function getDeletedDfsTree(deleteNodeId){
        let deletedDfsTree = dfsTree;
        for(let i=0;i<deletedDfsTree.length;i++){
            if(deleteNodeId == deletedDfsTree[i].parent) {
                deletedDfsTree.splice(i,1);
                break;
            }
        }
        for(let i=0;i<deletedDfsTree.length;i++){
            let childIdIndex = deletedDfsTree[i].children.indexOf(deleteNodeId);
            if(childIdIndex != -1) {
                deletedDfsTree[i].children(childIdIndex,1);
            }
        }
        return deletedDfsTree;
    }

    function dfs(nodes, visitingNode, beforeNode){
        isVisited[getNodeIndex(nodes, visitingNode.id)] = true;
        // 訪問時操作開始
        let visitingIndex = getNodeIndex(nodes, visitingNode.id);
        ordArray[visitingIndex] = ordNum;
        lowArray[visitingIndex] = ordNum;
        ordNum += 1;
        // 訪問時操作終了
        let neighborNodes = getNodeDeletedNodes(getNeighborNodes(visitingNode, nodes), beforeNode);
        neighborNodes.forEach(node => {
            let nextIndex = getNodeIndex(nodes, node.id);
            if(!isVisited[nextIndex] && nextIndex!==-1) {
                dfsTree.forEach((t,i)=>{if(t.parent==visitingNode.id)dfsTree[i].children.push(node.id);});
                dfs(nodes, node, visitingNode);
                if(lowArray[visitingIndex] > lowArray[nextIndex]) lowArray[visitingIndex] = lowArray[nextIndex];
            } else { //行こうとした先が訪問済だった時
                if(lowArray[visitingIndex]>ordArray[nextIndex]) lowArray[visitingIndex] = ordArray[nextIndex];
            }
        })
    }

    function getNodeDeletedNodes(nodes, node){
        let resNodes = [];
        for(let i=0;i<nodes.length;i++){
            if(nodes[i].id!=node.id){
                resNodes.push(nodes[i].deepCopy());
            }
        }
        return resNodes;
    }

    // coloring
    function doColoring(){
        if(isUndid) clearRedoStack();
        pushUndoStack(); //前の状態保存
        do{
            let beforeCalcNodes = getNodesCopy(Nodes);//操作前のノード達を避難
            let calcNodes = getRandomElements(beforeCalcNodes);//ランダムで複数個のノードを取得
            for(let i=0;i<calcNodes.length;i++){
                //各ノードで計算, 内部情報の更新
                calcingNode = calcNodes[i];
                let neighborNodes = getNeighborNodes(calcingNode, beforeCalcNodes);//操作前の隣人達
                if(isOutBiggerThan2(neighborNodes, calcingNode)){ // if Out(i)>2
                    Nodes[getNodeIndex(Nodes, calcingNode.id)].p =  getMaxX(neighborNodes)+1;
                }else if(isInColor(getOutEdges(neighborNodes, calcingNode), calcingNode.c)){
                    let tempNode = Nodes[getNodeIndex(Nodes, calcingNode.id)];
                    tempNode.c = getMinColor(getOutEdges(neighborNodes, calcingNode));
                    Nodes[getNodeIndex(Nodes, calcingNode.id)] = tempNode.deepCopy();
                }
            }
            // redrawCanvas();
        }while(isColoring());//彩色が終わるまで
        redrawCanvas();
        console.log("coloring finish")
    }

    function stepColoring(){
        if(isUndid) clearRedoStack();
        pushUndoStack(); //前の状態保存
        selectedNodes = []; //初期化
        let beforeCalcNodes = getNodesCopy(Nodes);//操作前のノード達を避難
        let calcNodes = getRandomElements(beforeCalcNodes);//ランダムで複数個のノードを取得
        for(let i=0;i<calcNodes.length;i++){
            //各ノードで計算, 内部情報の更新
            calcingNode = calcNodes[i];
            selectedNodes.push(calcingNode.id); //選択されたノードとして登録
            let neighborNodes = getNeighborNodes(calcingNode, beforeCalcNodes);//操作前の隣人達
            if(isOutBiggerThan2(neighborNodes, calcingNode)){ // if Out(i)>2
                Nodes[getNodeIndex(Nodes, calcingNode.id)].p =  getMaxX(neighborNodes)+1;
            }else if(isInColor(getOutEdges(neighborNodes, calcingNode), calcingNode.c)){
                let tempNode = Nodes[getNodeIndex(Nodes, calcingNode.id)];
                tempNode.c = getMinColor(getOutEdges(neighborNodes, calcingNode));
                Nodes[getNodeIndex(Nodes, calcingNode.id)] = tempNode.deepCopy();
            }
        }
        showProcessLog(beforeCalcNodes, Nodes);
        redrawCanvas();
        if(!isColoring())console.log("coloring finish");
    }

    function isColoring(){
        for(let i=0;i<Nodes.length;i++){
            let node = Nodes[i];
            let neighborNodes = getNeighborNodes(node, Nodes);
            for(let j=0;j<neighborNodes.length;j++){
                if(node.c == neighborNodes[j].c) return true;
            }
        }
        return false;
    }

    function getMinColor(outNodes){
        let tempColors = [0,1,2];
        outNodes.forEach(node=>{
            let res = tempColors.indexOf(node.c);
            if(res!==-1){
                tempColors.splice(res,1);
            }
        })
        let res = tempColors.reduce(function (a, b) {return Math.min(a, b);}); 
        return res;
    }

    function getOutEdges(neighborNodes, node){ //出辺先のノードの配列
        let outEdges = [];
        neighborNodes.forEach(neighbor => {
            if(neighbor.p>node.p) outEdges.push(neighbor);
            else if(neighbor.p==node.p && neighbor.id>node.id) outEdges.push(neighbor); 
        })
        return outEdges;
    }

    function isInColor(nodes, c){
        let b = false;
        nodes.forEach(node=>{
            if(node.c == c)b = true;
        })
        return b;
    }

    function getMaxX(nodes){
        let M = -1;
        nodes.forEach(node=>{
            if(node.p > M) M = node.p;
        })
        return M;
    }

    function isOutBiggerThan2(neighbors, node){
        let cnt = 0;
        neighbors.forEach(neighbor => {
            if(neighbor.p>node.p) cnt += 1;
            else if(neighbor.p==node.p && neighbor.id>node.id) cnt += 1; 
        })
        return cnt>2;
    }

    function getNeighborNodes(node, nodes){
        let neighborNodes = [];
        Edges.forEach(edge => {
            if(edge.start==node.id && isIdInNodes(nodes, edge.end)) neighborNodes.push(nodes[getNodeIndex(nodes, edge.end)].deepCopy());
            else if(edge.end==node.id  && isIdInNodes(nodes, edge.start)) neighborNodes.push(nodes[getNodeIndex(nodes, edge.start)].deepCopy());
        })
        return neighborNodes;
    }

    function getRandomElements(array){
        return array.filter(function(){
            return Math.random()>0.5;
        });
    }

    function getEdgesCopy(edges){
        let resEdges = [];
        edges.forEach(edge=>{
            resEdges.push(getEdgeCopy(edge));
        })
        return resEdges;
    }

    function getEdgeCopy(edge){
        return {start:edge.start, end:edge.end};
    }

    function getNodesCopy(nodes){
        let resNodes = [];
        nodes.forEach(node=>{
            resNodes.push(node.deepCopy());
        })
        return resNodes;
    }

    function getGraphsCopy(graphs){
        let resGraphs = [];
        graphs.forEach(graph => {
            resGraphs.push(getNodesCopy(graph));
        })
        return resGraphs;
    }

    class Node{
        constructor(x,y,id,p,c,vx,vy){
            this.x = x; 
            this.y = y;
            this.id = id; //ノード識別子
            this.p = p; //優先度決める値 
            this.c = c; //色 
            this.vx = vx;
            this.vy = vy;
        }
        
        deepCopy(){
            return new Node(this.x, this.y, this.id, this.p, this.c, this.vx, this.vy);
        }
    }
</script>
</body>
</html>