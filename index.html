<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Color the cactus graph with three colors</title>
<style>
    html{
        height: 100%;
        width: 100%;
    }
    body {
        width: 100%;
        height: 100%;
    }
    canvas {
        border: 1px solid #000;
        cursor: default;
    }
</style>
</head>
<body>
<canvas id="myCanvas"></canvas>
<input type="button" value="make random cactus graph" onclick="redrawRandomCactusGraph()">
<input type="button" value="make random uncactus graph" onclick="redrawRandomUnCactusGraph()">
<input type="button" value="check cactus graph" onclick="doCheckCactusGraph()">
<input type="button" value="test check cactus graph" onclick="doTestCheckCactusGraph()">
<input type="button" value="test check uncactus graph" onclick="doTestCheckUnCactusGraph()">
<input type="button" value="do minimize" onclick="redrawMinimumGraph()">
<input type="button" value="coloring graph" onclick="doColoring()">
<input type="number" value=15 id="graphSize">
<input type="number" value=15 id="graphComplex">
<input type="range" min="1" max="100" value="100" id="circleSize">
<!-- <textarea id="fileContent" cols="40" rows="8">5 5
1 2
1 3
3 2
5 2
4 2
</textarea> -->


<script>
    const canvas = document.getElementById('myCanvas');
    const ctx = canvas.getContext('2d');
    let Nodes = []; //{x, y, index, p, c, in, out}
    let Edges = []; //{Node1ID, Node2ID}
    let clickedNodeId = -1;
    let lastEvent = "";
    let edgeStartNodeId = -1;
    let isDrawingEdge = false;
    let isFinishedMove = true;
    let circleSize = 0;
    let nodeIdNow = 0;
    let Color = [0,1,2];//赤, 青, 黃
    let colorName = ["red", "blue", "yellow"]
    let beforeMinBodySize = 0;
    let changeCircleSize = 100;
    let BOUNCE = 0.9;
    let FRICTION = 0.3;
    let SPRINGLENGTH = circleSize*10;
    let COULOMB = 5000;
    let GRAVITY = 0.00002;

    let visitTime = {};

    function doAtFirst(){
        beforeMinBodySize = Math.min(document.body.clientHeight,document.body.clientWidth);
        resizeWindow();
        initialize();
        setInterval(makeBalancedGraph, 50);
    }

    function initialize(){
        Nodes = [];
        Edges = [];
        clickedNodeId = -1;
        lastEvent = "";
        edgeStartNodeId = -1;
        isDrawingEdge = false;
        isFinishedMove = true;
        nodeIdNow = 0;
    }

    function resizeWindow(){ // canvasのサイズを変更
        let minSize = Math.min(document.body.clientHeight,document.body.clientWidth);
        canvas.width = minSize*3/4;
        canvas.height = minSize*3/4;
        circleSize = minSize/40;
        SPRINGLENGTH = circleSize*4;
        redrawCanvas();
        beforeMinBodySize = minSize; //描画後に今のcanvasのサイズを保存
    }

    function getCanvasSize(){
        return canvas.width;
    }

    function drawNode(x, y, c, id) { //円を描写
        let canvasSize = Math.min(document.body.clientHeight,document.body.clientWidth);
        ctx.beginPath();
        ctx.arc(x, y, circleSize*changeCircleSize/100, 0, Math.PI * 2);
        ctx.fillStyle = colorName[c];
        ctx.fill();
        ctx.strokeStyle = 'black'; 
        ctx.stroke(); 
        // ctx.fillStyle = 'black';
        // ctx.fillText(id, x, y);
        ctx.closePath();
    }

    function setCircleSize(){
        changeCircleSize = document.getElementById("circleSize").value;
    }

    function drawEdge(i, j){// idがi,jのノード間にエッジ
        let NodeI = getNodeIndex(Nodes, i);
        let NodeJ = getNodeIndex(Nodes, j);
        let xi = Nodes[NodeI].x;
        let yi = Nodes[NodeI].y;
        let xj = Nodes[NodeJ].x;
        let yj = Nodes[NodeJ].y;
        drawLine(xi, yi, xj, yj);
        // drawSquare((xi+xj)/2-5, (yi+yj)/2-5, 10);
      
    }

    function drawLine(x0, y0, x1, y1){
        ctx.beginPath();
        ctx.moveTo(x0, y0);
        ctx.lineTo(x1, y1);
        ctx.strokeStyle = 'black'; 
        ctx.stroke();
        ctx.closePath();
    }

    function drawSquare(x,y,width){
        ctx.beginPath();
        ctx.rect(x, y, width, width);
        ctx.strokeStyle = "black";
        ctx.stroke();
        ctx.closePath();
    }

    // Function to clear the canvas
    function clearCanvas() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
    }

    // Function to redraw all Nodes
    function redrawNodes() {
        for(let i=0;i<Nodes.length;i++){
            if(Nodes[i].x<=0) Nodes[i].x = 0; //左の壁
            else if(Nodes[i].x>=beforeMinBodySize*3/4) Nodes[i].x = beforeMinBodySize*3/4; //右の壁
            if(Nodes[i].y<=0) Nodes[i].y = 0; //上の壁
            else if(Nodes[i].y>=beforeMinBodySize*3/4) Nodes[i].y = beforeMinBodySize*3/4; // 下の壁

            // Nodes.forEach(node=>{
            //     if(node.id!=Nodes[i].id){//自分以外のノードに対して
            //         let dstX = Nodes[i].x - node.x;
            //         let dstY = Nodes[i].y - node.y;
            //         let dstSQRT = Math.sqrt(dstX * dstX + dstY * dstY);
            //         if(dstSQRT<2*circleSize){
            //             Nodes[i].x += dstX*circleSize/dstSQRT;
            //             Nodes[i].y += dstY*circleSize/dstSQRT;
            //         }
            //     }
            // })

            drawNode(Nodes[i].x, Nodes[i].y, Nodes[i].c, Nodes[i].id);
        }
        // console.log(Nodes[0])
    }
    function redrawEdges(){
        Edges.forEach(Edge => {
            drawEdge(Edge.start, Edge.end);
        });
    }

    function redrawCanvas(){
        // ノード座標の更新
        let nowMinBodySize = Math.min(document.body.clientHeight,document.body.clientWidth);
        for(let i=0;i<Nodes.length;i++){
            Nodes[i].x = Nodes[i].x * nowMinBodySize / beforeMinBodySize;
            Nodes[i].y = Nodes[i].y * nowMinBodySize / beforeMinBodySize;
        }
        clearCanvas();
        redrawEdges();
        redrawNodes();
    }

    function makeBalancedGraph(){
        for(let i=0;i<Nodes.length;i++){
            if(Nodes[i].id!=clickedNodeId){
                let fx = 0;
                let fy = 0;
                Nodes.forEach(colombedNode=>{
                    if(colombedNode.id!=Nodes[i].id){
                        let dstX = Nodes[i].x - colombedNode.x ;
                        let dstY = Nodes[i].y - colombedNode.y;
                        let dstSQRT = Math.sqrt(dstX * dstX + dstY * dstY);
                        let f = COULOMB/(dstSQRT*dstSQRT) //クーロン力
                        if(dstSQRT==0) dstSQRT = 0.5;
                        fx += f * dstX/dstSQRT;
                        fy += f * dstY/dstSQRT;
                    }
                })
                if(isNaN(fx)) fx = 0;
                if(isNaN(fy)) fy = 0;

                Nodes.forEach(frictionedNode=>{
                    if(frictionedNode.id!=Nodes[i].id && isNeighbor(frictionedNode, Nodes[i])){
                        let dstX = frictionedNode.x - Nodes[i].x;
                        let dstY = frictionedNode.y - Nodes[i].y;
                        let dstSQRT = Math.sqrt(dstX * dstX + dstY * dstY);
                        let f = BOUNCE * (dstSQRT - SPRINGLENGTH); //フックの法則による力
                        if(dstSQRT==0) dstSQRT = 0.5;
                        fx += f * dstX/dstSQRT;
                        fy += f * dstY/dstSQRT;
                    }
                })

                // if(isNaN(fx)) fx = 0;
                // if(isNaN(fy)) fy = 0;

                let gDstX =  Nodes[i].x-canvas.width/2;
                let gDstY =  Nodes[i].y-canvas.width/2;
                let gDst = Math.sqrt(gDstX*gDstX + gDstY*gDstY);
                let gF = -1*GRAVITY * (gDst*gDst);
                fx += gF * gDstX/gDst;
                fy += gF * gDstY/gDst;
                // console.log(gF);

                Nodes[i].vx = (Nodes[i].vx + fx) * FRICTION; //摩擦
                Nodes[i].vy = (Nodes[i].vy + fy) * FRICTION; //摩擦

                Nodes[i].x += Nodes[i].vx;
                Nodes[i].y += Nodes[i].vy;
            }
        }
        redrawCanvas();
    }

    function isNeighbor(node1, node2){
        for(let i=0;i<Edges.length;i++){
            if((Edges[i].start == node1.id && Edges[i].end   == node2.id)||
               (Edges[i].end   == node1.id && Edges[i].start == node2.id)) return true;
        }
        return false;
    }

    function removeEdgesById(edges, id){
        // return array.filter(function(element){
        //     return (element.start != id && element.end != id);
        // });
        let resEdges = [];
        edges.forEach(edge=>{
            if(edge.start!=id&&edge.end!=id){
                resEdges.push(getEdgeCopy(edge));
            }
        })
        return resEdges;
    }

    function getNodeIndex(nodes, id) {
        let index = nodes.findIndex(node => node.id == id);
        return index !== -1 ? index : -1;
    }

    function handleMouseDown(event){
        clickedNodeId = -1;
        const rect = canvas.getBoundingClientRect();
        const x = event.clientX - rect.left;
        const y = event.clientY - rect.top;
        Nodes.forEach(Node => {
            const dx = x - Node.x;
            const dy = y - Node.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            if (distance < circleSize) {
                clickedNodeId = Node.id;
            }
        });

        lastEvent = "mousedown";
    }

    function handleMouseUp(event){
        clickedNodeId = -1;

        lastEvent = "mouseup";
    }

    function handleClick(event){
        if(isFinishedMove){
            const rect = canvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;

            clickedNodeId = -1;
            Nodes.forEach(Node => {
                const dx = x - Node.x;
                const dy = y - Node.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                if (distance < circleSize) {
                    clickedNodeId = Node.id;
                }
            });
            if(clickedNodeId !== -1){
                if(!isDrawingEdge){
                    edgeStartNodeId = clickedNodeId;
                    isDrawingEdge = true;
                }else{
                    if(edgeStartNodeId !== clickedNodeId){
                        Edges.push({start: edgeStartNodeId, end: clickedNodeId});
                    }
                    isDrawingEdge = false;
                }
            }
        }
        isFinishedMove = true;
        redrawCanvas();
    }

    // Function to handle mouse click
    function handleDoubleClick(event) {
        const rect = canvas.getBoundingClientRect();
        const x = event.clientX - rect.left;
        const y = event.clientY - rect.top;

        clickedNodeId = -1;
        Nodes.forEach(Node=> {
            const dx = x - Node.x;
            const dy = y - Node.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            if (distance < circleSize) {
                clickedNodeId = Node.id;
            }
        });

        if (clickedNodeId !== -1) {
            Nodes.splice(getNodeIndex(Nodes, clickedNodeId), 1); // Remove the clicked Node
            Edges = removeEdgesById(Edges, clickedNodeId);
            clickedNodeId = -1;
            isDrawingEdge = false;
        } else {
            Nodes.push(new Node(x, y, nodeIdNow, nodeIdNow++, 0, 0, 0)); // Add a new Node
        }

        redrawCanvas();
    }

    // Function to handle mouse drag
    function handleDrag(event) {
        if(event.buttons == 1){
            isFinishedMove = false;
            const rect = canvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;
            // Find the Node being dragged
            if (event.buttons === 1 && clickedNodeId!==-1) {
                let Node = Nodes[getNodeIndex(Nodes, clickedNodeId)];
                Node.x = x;
                Node.y = y;
                redrawCanvas();
            }
        }
        
    }


    // Event listeners
    canvas.addEventListener('mousedown', handleMouseDown);
    canvas.addEventListener('mouseup', handleMouseUp);
    canvas.addEventListener('click', handleClick);
    canvas.addEventListener('dblclick', handleDoubleClick);
    canvas.addEventListener('mousemove', handleDrag);
    window.addEventListener("DOMContentLoaded", doAtFirst);
    window.addEventListener("resize", resizeWindow);
    let slider = document.getElementById("circleSize");
    slider.addEventListener("input", setCircleSize);

    // make graph
    function redrawRandomCactusGraph(){
        initialize();
        makeRandomCactusGraph();
        clearCanvas();
        redrawCanvas();
    }

    function redrawRandomUnCactusGraph(){
        initialize();
        makeRandomUnCactusGraph();
        clearCanvas();
        redrawCanvas();
    }

    function makeRandomCactusGraph(){// w回c個から成る部分グラフ生成
        let graphSize = document.getElementById("graphSize").value;
        let graphComplex = document.getElementById("graphComplex").value;
        Nodes = [];
        Edges = [];
        // console.log("start make cactus");
        let camvasSize = getCanvasSize();
        let beginNode = new Node(Math.random()*camvasSize, Math.random()*camvasSize, nodeIdNow, nodeIdNow++, 0, 0, 0); //開始ノード作成
        Nodes.push(beginNode);//ノードとして登録
        for(let i=0;i<graphSize;i++){
            let nowNode = Nodes[Math.floor(Math.random()*Nodes.length)];//ノード選択
            makeRandomGraph(nowNode, graphComplex);
        }
    }

    function makeRandomUnCactusGraph(){
        let graphSize = document.getElementById("graphSize").value;
        let graphComplex = document.getElementById("graphComplex").value;
        Nodes = [];
        Edges = [];
        // console.log("start make uncactus");
        let camvasSize = getCanvasSize();
        let beginNode = getRandomNode();
        Nodes.push(beginNode);//ノードとして登録
        makeRandomCycle(beginNode, Math.floor(Math.random()*(graphComplex-3)+3)); //3以上graphComplex以下の長さの閉路作成
        let randomNodeIndex1 = Math.floor(Math.random()*Nodes.length);
        let randomNodeIndex2 = Math.floor(Math.random()*Nodes.length);
        if(randomNodeIndex1==randomNodeIndex2) randomNodeIndex2 = (randomNodeIndex1+1)%Nodes.length;
        makeRandomCycleFromPath(Nodes[randomNodeIndex1], Nodes[randomNodeIndex2], graphComplex); //閉路から閉路を生やす
        for(let i=0;i<graphSize;i++){
            let nowNode = Nodes[Math.floor(Math.random()*Nodes.length)];//ノード選択
            makeRandomGraph(nowNode, graphComplex);
        }
    }

    function makeRandomCycleFromPath(node1, node2, cycleLength){
       
        let nextNode = node1;
        let cnt = 0;
        let randomCycleLength = Math.floor(Math.random()*(cycleLength-3)+3);
        do{
            let parentNode = nextNode;//最後のノードを取得
            let childNode = getRandomNode(); 
            Nodes.push(childNode);
            Edges.push({start: parentNode.id, end: childNode.id});
            nextNode = childNode;//最後のノード更新
            cnt += 1;
        }while(cnt<randomCycleLength);
        Edges.push({start: nextNode.id, end: node2.id});
    }

    function makeNotCactusGraph(beginNode, c){ //２つの閉路がくっついた形のグラフを一つ作る
        makeRandomCycle(beginNode, c); //閉路を１つ生成
        
        if(randomNodeIndex1==randomNodeIndex2) randomNodeIndex2 = (randomNodeIndex1+1)%Nodes.length;
        let onCycleNode1 = Nodes[randomNodeIndex1];
        let onCycleNode2 = Nodes[randomNodeIndex2];
        
    }

    function makeRandomGraph(nowNode, c){
        if(Math.random()>0.5){
            makeRandomCycle(nowNode, c);
        }else{
            makeRandomTree(nowNode, c);
        }
    }

    function makeRandomTree(rootNode, pathLength){//rootNodeを根, ノード数c
        let treeNodes = [];
        treeNodes.push(rootNode);
        let cnt = 0;
        let randomPathLength = Math.floor(Math.random()*(pathLength-2)+2);
        do{
            let parentNode = treeNodes[Math.floor(Math.random()*treeNodes.length)]; //親取得
            let childNodes = [];
            let childrenSize = Math.floor(Math.random()*randomPathLength); //子の数決定
            for(let i=0;i<childrenSize;i++){
                let childNode = getRandomNode();//子生成
                Nodes.push(childNode);//子をノードとして登録
                Edges.push({start: parentNode.id, end: childNode.id});//エッジ作成
                treeNodes.push(childNode);
                cnt += 1;
            }
        }while(cnt<randomPathLength);
    }

    function makeRandomCycle(rootNode, cycleLength){
        let nextNode = rootNode;
        let cnt = 0;
        let randomCycleLength = Math.floor(Math.random()*(cycleLength-3)+3);
        do{
            let parentNode = nextNode;//最後のノードを取得
            let childNode = getRandomNode(); 
            Nodes.push(childNode);
            Edges.push({start: parentNode.id, end: childNode.id});
            nextNode = childNode;//最後のノード更新
            cnt += 1;
        }while(cnt<randomCycleLength);
        Edges.push({start: nextNode.id, end: rootNode.id});
    }

    function getRandomNode(){
        let camvasSize = getCanvasSize();
        return new Node(Math.random()*camvasSize, Math.random()*camvasSize, nodeIdNow, nodeIdNow++, 0, 0, 0);
    }

    function isIdInNodes(nodes, id){
        let isIn = false;
        nodes.forEach(node=>{
            if(node.id===id) isIn = true;
        })
        return isIn;
    }

    // 前処理
    let minNodes = [];
    let minEdges = [];
    function doMinimizeOnIsCactusGraph(){
        minNodes = getNodesCopy(Nodes);
        minEdges = getEdgesCopy(Edges);
        deleteLeavesMinNodesEdges(); // 次数1以下のノードを削除
        deleteEdgesOnCycle(); // 閉路をなるべく小さくする
    }

    function redrawMinimumGraph(){
        doMinimizeOnIsCactusGraph();
        Nodes = getNodesCopy(minNodes);
        Edges = getEdgesCopy(minEdges);
        redrawCanvas();
    }

    function deleteEdgesOnCycle(){ // 閉路をなるべく小さくする 次数2かつ各隣接ノードが隣接していないなら削除
        let deleteNodeIds = [];
        for(let i=0;i<minNodes.length;i++){ //ノードを順番に参照
            let cnt=0;
            let isFind = false;
            let nodeId1 = -1;
            let nodeId2 = -1;
            minEdges.forEach(edge=>{
                if(edge.start==minNodes[i].id){ //エッジの片方が一致するなら
                    if(cnt==0)nodeId1 = edge.end;
                    else nodeId2 = edge.end;
                    cnt++;
                }else if(edge.end==minNodes[i].id){ //エッジの片方が一致するなら
                    if(cnt==0) nodeId1 = edge.start;
                    else nodeId2 = edge.start;
                    cnt++;
                }
            })
            if(cnt==2){ // 次数が2ならば
                let isTriangle = false;
                for(let j=0;j<minEdges.length;j++){//三角形を成すか判定
                    if((minEdges[j].start==nodeId1&&minEdges[j].end==nodeId2)||(minEdges[j].start==nodeId2&&minEdges[j].end==nodeId1)) { //nodeとnodeId1とnodeId2で三角形を成すならば
                       
                        isTriangle = true;
                        break; //三角形ならば次のノードへ
                    }
                }
                if(!isTriangle){//三角形でないならば

                    


                    minEdges = removeEdgesById(minEdges, minNodes[i].id);//削除処理
                    minNodes.splice(getNodeIndex(minNodes, minNodes[i].id), 1);//削除処理
                    minEdges.push({start:nodeId1, end:nodeId2});//エッジ追加
                    isFind = true;

                }
            }
            if(isFind){//削除が行われたならば
                deleteEdgesOnCycle();//削除後のグラフに対して削除処理
                break;
            }
        }
    }

    function deleteLeavesMinNodesEdges(){ //次数1以下のノードを削除
        let isContinueDelete = false;
        let deleteNodeIds = [];
        if(minNodes.length>2){
            minNodes.forEach((node,i)=>{
                let cnt = 0;
                minEdges.forEach(edge=>{
                    if(edge.start==node.id || edge.end==node.id) cnt++;
                })
                if(cnt<=1) {
                    isContinueDelete = true;
                    deleteNodeIds.push(node.id);
                }
            })
            deleteNodeIds.forEach(nodeId=>{
                minNodes.splice(getNodeIndex(minNodes, nodeId), 1);
                minEdges = removeEdgesById(minEdges, nodeId);
            });
            if(isContinueDelete) deleteLeavesMinNodesEdges();
        }
    }

    // cactus check
    function doTestCheckCactusGraph(){
        do{
            redrawRandomCactusGraph();
            doCheckCactusGraph();
            if(!isCactus)break;
        }while(true);
    }

    function doTestCheckUnCactusGraph(){
        do{
            redrawRandomUnCactusGraph();
            doCheckCactusGraph();
            if(isCactus)break;
        }while(true);
    }

    let originNodes = [];
    let originEdges = [];
    function doCheckCactusGraph(){
        doMinimizeOnIsCactusGraph();
        
        originNodes = getNodesCopy(Nodes);
        originEdges = getEdgesCopy(Edges);
        Nodes = getNodesCopy(minNodes);
        Edges = getEdgesCopy(minEdges);

        isCycle = false;
        isCactus = true;
        separatedGraphs = [getNodesCopy(Nodes)];
        isCactusGraph(Nodes);
        if(isCactus)console.log("yes cactus");
        else console.log("no cactus");

        Nodes = getNodesCopy(originNodes);
        Edges = getEdgesCopy(originEdges);
        redrawCanvas();
    }

    let separatedGraphs = [];
    let lastSeparatedGraphs = [];
    let jointNodes = [] //関節点を格納
    let isCactus = true;
    function isCactusGraph(nodes){ //全ての関節点を取得し, 各関節点除去時に, 3なら非カクタス, 2なら閉路判定, 1ならパス
        //まず関節点配列の作成
        makeJointNodes(nodes);
        //各関節点に対して処理
        for(let jointNodeIndex=0;jointNodeIndex<jointNodes.length;jointNodeIndex++){
            let nowJointNode = jointNodes[jointNodeIndex] //処理を行う関節点
            //関節点を削除して分割されたグラフと削除されたエッジの数とエッジが削除されたノードを取得
            let jointNodeDeletedNodes = getNodeDeletedNodes(nodes, nowJointNode);//関節点を削除したノード配列
            makeSeparatedNodes(jointNodeDeletedNodes) //分割されたグラフを作成
            //各グラフに対して, 消えたエッジの数に応じた処理を実行
            for(let separatedGraphIndex=0;separatedGraphIndex<separatedGraphs.length;separatedGraphIndex++){//各グラフに対して
                let deletedEdgeNum = getDeletedEdgeNum(separatedGraphs[separatedGraphIndex], nodes); //グラフからエッジが何本消えたか
                if(deletedEdgeNum>=3) { // 消えたエッジが3本以上の時
                    isCactus = false;
                }else if(deletedEdgeNum===2){ //消えたエッジが2本の時
                    let edgeDeletedNodes = getEdgeDeleted2NodeIds(separatedGraphs[separatedGraphIndex], nodes);
                    visitedIsConnected1 = [];
                    visitedIsConnected2 = [];
                    separatedGraphs[separatedGraphIndex].forEach(node=>{visitedIsConnected1.push(false);visitedIsConnected2.push(false);});
                    getPathFromNodeToNode(edgeDeletedNodes[0], edgeDeletedNodes[1], separatedGraphs[separatedGraphIndex]);
                    if(separatedGraphs[separatedGraphIndex].length>2){
                        for(let searchPathStackIndex1=0;searchPathStackIndex1<searchPathStack.length-1;searchPathStackIndex1++){
                            for(let searchPathStackIndex2=searchPathStackIndex1+1;searchPathStackIndex2<searchPathStack.length;searchPathStackIndex2++){
                                isCycle = false;
                                connectedDfs(searchPathStack[searchPathStackIndex1], 
                                        separatedGraphs[separatedGraphIndex], 
                                        -1, 
                                        1, 
                                        [searchPathStack[searchPathStackIndex1], searchPathStack[searchPathStackIndex2]]);
                                if(isCycle) {
                                    isCactus = false;
                                    break;
                                }
                            }
                            if(isCycle){
                                break;
                            }
                        }
                    }
                }
                if(!isCactus){
                    break;
                }
            }
            if(!isCactus){
                break;
            }
        }
    }



    let isVisited = []; //再帰で参照し続けるのでグローバル dfs
    let lowArray = []; //再帰で参照し続けるのでグローバル dfs
    let ordArray = []; //再帰で参照し続けるのでグローバル dfs
    let ordNum = 1; //再帰で参照し続けるのでグローバル dfs
    let dfsTree = []; //{parent:id, children:[id1, ... idk]} dfs木を隣接リストで作る
    function makeJointNodes(nodes){ //nodesの関節点を作成
        isVisited = [];
        lowArray = [];
        ordArray = [];
        nodes.forEach(node=>{
            isVisited.push(false);
            lowArray.push(-1);
            ordArray.push(-1);
            dfsTree.push({parent:node.id, children:[]});
        });
        ordNum = 1;
        //ord, low, dfsTreeを作成
        makeOrdAndLowDfs(nodes, nodes[0], nodes[0]);
        isVisited = [];
        nodes.forEach(node=>{isVisited.push(false)});
       
        //関節点の配列を作成
        makeJointNodesDfs(nodes, nodes[0], true);
    }

    function makeJointNodesDfs(nodes, visitingNode, isStart){//jointNodesに関節点を格納
        let visitingNodeIndex = getNodeIndex(nodes, visitingNode.id); //nodes上のインデックス取得
        isVisited[visitingNodeIndex] = true; //訪問済にする
        let neighborNodes = getNeighborNodes(visitingNode, nodes); //隣接ノードを取得
        if(isStart){//ルートの時
            // if(neighborNodes.length>=2) jointNodes.push(visitingNode); //子が2つ以上なら関節点
        }
        neighborNodes.forEach(neighborNode=>{//各隣接ノードに対して
            let neighborIndex = getNodeIndex(nodes, neighborNode.id); //隣接ノードのインデックス
            if(ordArray[visitingNodeIndex]<=lowArray[neighborIndex] && !isIdInNodes(jointNodes, visitingNode.id)) jointNodes.push(visitingNode); //関節点か確認
            if(!isVisited[neighborIndex]){ //未訪問ならば
                makeJointNodesDfs(nodes, neighborNode, false);
            }
        })
    }

    function makeOrdAndLowDfs(nodes, visitingNode, beforeNode){  //ord, low, dfsTreeを作成
        isVisited[getNodeIndex(nodes, visitingNode.id)] = true;
        // 訪問時操作開始
        let visitingIndex = getNodeIndex(nodes, visitingNode.id);
        ordArray[visitingIndex] = ordNum;
        lowArray[visitingIndex] = ordNum;
        ordNum += 1;
        // 訪問時操作終了
        let neighborNodes = getNodeDeletedNodes(getNeighborNodes(visitingNode, nodes), beforeNode);
        neighborNodes.forEach(node => {
            let nextIndex = getNodeIndex(nodes, node.id);
            if(!isVisited[nextIndex] && nextIndex!==-1) {
                dfsTree.forEach((t,i)=>{if(t.parent==visitingNode.id)dfsTree[i].children.push(node.id);});
                dfs(nodes, node, visitingNode);
                if(lowArray[visitingIndex] > lowArray[nextIndex]) lowArray[visitingIndex] = lowArray[nextIndex];
            } else { //行こうとした先が訪問済だった時
                if(lowArray[visitingIndex]>ordArray[nextIndex]) lowArray[visitingIndex] = ordArray[nextIndex];
            }
        })
    }

    let searchPathStack = []; //パスを格納
    let visitedSearchPathQueue = [];
    let prevNodes = []; // 経路復元に使う
    function getPathFromNodeToNode(startNode, goalNode, graph){// searchPathStackにパスを記録
        searchPathStack = [];
        pathStack = [];
        visitedSearchPath = [];
        visitedSearchPathQueue = [];
        prevNodes = [];
        graph.forEach(graph=>{prevNodes.push(-2)});
        prevNodes[getNodeIndex(graph, startNode.id)] = -1; 
        visitedSearchPathQueue.push(startNode);
        isFindPath = false;
    
        searchPathBfs(startNode, graph, goalNode);
        
        restoreBfsPath(graph, goalNode);
    }

    function restoreBfsPath(graph, goalNode){
        let nowNodeIndex = getNodeIndex(graph, goalNode.id); 
        do{
            searchPathStack.push(graph[nowNodeIndex].id);
            if(prevNodes[nowNodeIndex]==-1) break;
            nowNodeIndex = prevNodes[nowNodeIndex];
        }while(true)
    }

    let isFindPath = false;
    function searchPathBfs(visitingNode, graph, goalNode){ //BFSにより最短パスを探索
        let visitingNodeId = visitingNode.id;
        let visitingNodeIndex = getNodeIndex(graph, visitingNodeId);
        visitedSearchPath[visitingNodeIndex] = true;
        do{
            let nowNode = visitedSearchPathQueue.shift();
            let neighborNodes = getNeighborNodes(nowNode, graph);
            neighborNodes.forEach(node=>{
                let nextNodeIndex = getNodeIndex(graph, node.id);
                if(prevNodes[nextNodeIndex]>=-1){

                }else{
                    prevNodes[nextNodeIndex] = getNodeIndex(graph, nowNode.id);
                    visitedSearchPathQueue.push(node);
                }
            })
        }while(visitedSearchPathQueue.length>0)
    }

    function getEdgeDeleted2NodeIds(nowGraph, lastGraph){
        let resNodes = [];
        nowGraph.forEach(node=>{
            Edges.forEach(edge=>{
                if(node.id==edge.start){ //今のグラフ上のあるノードとエッジの始点が一致したなら
                    if(isIdInNodes(lastGraph, edge.end) && !isIdInNodes(nowGraph, edge.end)){//前のグラフにあって今のグラフにないノードならば関節点であるため
                        resNodes.push(nowGraph[getNodeIndex(nowGraph,edge.start)].deepCopy());
                    }
                }else if(node.id==edge.end){
                    if(isIdInNodes(lastGraph, edge.start) && !isIdInNodes(nowGraph, edge.start)){//前のグラフにあって今のグラフにないノードならば
                        resNodes.push(nowGraph[getNodeIndex(nowGraph,edge.end)].deepCopy());
                    }
                }
            })
        })
        return resNodes;
    }

    function getAddedNodes(nodes1, nodes2){
        node2.forEach(node=>{ //既にないなら追加
            if(!isIdInNodes(nodes1, node.id)) nodes1.push(node);
        })
        return nodes1;
    }

    function getSubtractedNodes(nodes1, nodes2){
        node2.forEach(node=>{ //既にあるなら削除
            if(isIdInNodes(nodes1, node.id)) nodes1.splice(getNodeIndex(nodes1, node.id),1);
        })
        return nodes1;
    }
    
    let visitedIsConnected1 = []; 
    let isCycle = false;
    //separatedGraphs[i]-searchPathStack+searchPathStack[j]+searchPathStack[j]の中でsearchPathStack[j]からsearchPathStack[j]に到達できるか
    function connectedDfs(nodeId, graph, beforeNodeId, visitNum, nodesInCycle){ 
        let visitingIndex = getNodeIndex(graph, nodeId);
        visitedIsConnected1[visitingIndex] = true;
       
        let childNodes = getNeighborNodes(graph[visitingIndex], graph);
        if(visitNum>=2) childNodes = getNodeDeletedNodes(childNodes, graph[getNodeIndex(graph, beforeNodeId)]);
        let teststr = "childs:[";
        childNodes.forEach(node=>{
            teststr+=node.id+" ";
        })
        // console.log(teststr+"]")
        childNodes.forEach(node=>{
            if((!searchPathStack.includes(nodeId)&&searchPathStack.includes(node.id)) || (searchPathStack.includes(nodeId)&&!searchPathStack.includes(node.id))||(!searchPathStack.includes(nodeId)&&!searchPathStack.includes(node.id))){ //スタートの隣のゴールではない
                
                if(!visitedIsConnected1[getNodeIndex(graph, node.id)] //未訪問である
                    && node.id!=beforeNodeId  //親ノードではない
                    && (!searchPathStack.includes(node.id))) { //サーチパスにない
                    //子供を訪問 親には訪問しない
                   
                    connectedDfs(node.id, graph, nodeId, visitNum+1, nodesInCycle);
                } else if(searchPathStack.includes(node.id)
                    && node.id!=nodesInCycle[0] //ゴールである 
                    && node.id!=beforeNodeId) { //親ノードではない
               
                    isCycle=true;
                }
            }
        })
    }

    function getDeletedEdgeNum(nowNodes, lastNodes){//分離前(直前)のグラフと比較
        let cnt = 0;
        nowNodes.forEach(node=>{//部分グラフの各ノードについて
            Edges.forEach(edge=>{
                if(node.id===edge.start){
                    if(isIdInNodes(lastNodes, edge.end) && !isIdInNodes(nowNodes, edge.end)) {
                        cnt++;
                    }
                }else if(node.id===edge.end){
                    if(isIdInNodes(lastNodes, edge.start) && !isIdInNodes(nowNodes, edge.start)) {
                        cnt++;
                    }
                }
            })
        })
        return cnt;
    }

    function getLastGraph(node){
        let resGraph = [];
        lastSeparatedGraphs.forEach(graph=>{
            if(isIdInNodes(graph, node.id)){
                resGraph = getNodesCopy(graph);
            }
        })
        return resGraph;
    }

    
    // let separatedGraphs = [];// 分割結果を格納する
    let deletedNodes = []; //ノードを削除したあとのノード集合
    function getSeparatedGraphs(nodes){//nodesの関節点を削除し, node配列の配列を返す 
        separatedGraphs = [];// 分割結果を格納するので初期化
        deletedNodes = getNodesCopy(nodes); //削除処理用のノード配列を作成
        isVisited = []; //初期化
        lowArray = [];
        ordArray = [];
        ordNum = 1;
        dfsTree = [];
        nodes.forEach(node=>{
            isVisited.push(false);
            lowArray.push(-1);
            ordArray.push(-1);
            dfsTree.push({parent:node.id, children:[]});
        });
        let beginNode = nodes[0]; //dfsを開始するノード
        dfs(nodes, beginNode, beginNode); //dfs木, low, ordを作成 再帰です
        // 今から, dfs木を辿って関節点を探します. dfsTree上で全ての関節点を削除します.
        isVisited.forEach((n,i)=>{ //今からまた使うので初期化
            isVisited[i] = false;
        })
        deleteDfs(nodes, beginNode.id, true); //deletedNodesに関節点を除いたノード集合を格納
        
        makeSeparatedNodes(); // separatedGraphsに分割されたグラフを格納
        return separatedGraphs;
    }

    function makeSeparatedNodes(nodes){ //nodesを分割してseparatedGraphsに格納
        separatedGraphs = []//初期化
        isVisited = [];// 初期化
        nodes.forEach(node=>{isVisited.push(false);})
        let beginNode = nodes[0];
        nodes.forEach((node,i)=>{
            if(!isVisited[i]) {
                separatedGraphs.push([]); //このグラフを記録する配列を追加
                unionDfs(nodes, node); //訪問済で無ければDFS
            }
        })
    }

    function unionDfs(nodes, visitingNode){
        visitingIndex = getNodeIndex(nodes, visitingNode.id); //訪問しているノード
        isVisited[visitingIndex] = true; //訪問済にする
        separatedGraphs[separatedGraphs.length-1].push(visitingNode); //分割されたグラフの一部として登録
        let childNodes = getNeighborNodes(visitingNode, nodes); //隣接ノードを取得
        childNodes.forEach(node=>{ //隣接ノード一つずつに対して処理
            let childIdIndex = getNodeIndex(nodes, node.id);
            if(!isVisited[childIdIndex] && childIdIndex!==-1){
                unionDfs(nodes, node);
            }
        })
    }

    

    let beforeDeletedNodes = [];
    let isDeleted = false;
    function deleteDfs(nodes, visitingId, isStart){ //nodesからvisitingIdを消せるなら消す
        if(isStart){
            beforeDeletedNodes = getNodesCopy(nodes);
            isDeleted = false;
        }
        if(nodes.length==1) return;
        visitingIndex = getNodeIndex(nodes, visitingId); //Nodes上のインデックス
        isVisited[visitingIndex] = true; //isVisitedはNodesに対応
        let childIds = getDfsTreeChildren(visitingIndex); //DFStree上の子ノード達を取得
        let isExist = false;
        childIds.forEach(childId => {// 各子どもたちに対して
            let nextIndex = getNodeIndex(nodes, childId); //Nodes上のインデックス
            if(!isStart && ordArray[visitingIndex]<=lowArray[nextIndex] &&  isIdInNodes(deletedNodes,visitingId)) {
                isExist = true;
            }
            if(!isVisited[nextIndex] && !isDeleted) deleteDfs(nodes, childId, false);
        })

        // 削除処理開始
        if(!isDeleted){
            if(isExist || (isStart&&childIds.length>=2)) {
                deletedNodes.splice(getNodeIndex(deletedNodes, visitingId),1);//削除処理
                isDeleted = true;
            }
            if(isStart && childIds.length<2){
                if(beforeDeletedNodes.length==nodes.length) {//関節点がない場合は次数最大の点を消す
                    deletedNodes.splice(getNodeIndex(deletedNodes, getMaxDegreeId(nodes)),1); //削除処理
                    isDeleted = true;
                }
            }
        }
        //削除処理終了
    }


    function getMaxDegreeId(nodes){ // nodes内の最大次数のノードのidを返す
        let maxDegreeId = -1;
        let maxDegree = -1;
        nodes.forEach(node=>{
            let nowDegree = 0;
            Edges.forEach(edge=>{
                if(node.id==edge.start && isIdInNodes(nodes, edge.end)){
                    nowDegree++;
                }else if(node.id==edge.end && isIdInNodes(nodes, edge.start)){
                    nowDegree++;
                }
            })
            if(nowDegree>maxDegree) maxDegreeId = node.id;
        })
        return maxDegreeId;
    }

    function getDfsTreeChildren(parentId){
        for(let i=0;i<dfsTree.length;i++){
            if(parentId == dfsTree[i].parent) return dfsTree[i].children;
        }
        return dfsTree;
    }

    function getDeletedDfsTree(deleteNodeId){
        let deletedDfsTree = dfsTree;
        for(let i=0;i<deletedDfsTree.length;i++){
            if(deleteNodeId == deletedDfsTree[i].parent) {
                deletedDfsTree.splice(i,1);
                break;
            }
        }
        for(let i=0;i<deletedDfsTree.length;i++){
            let childIdIndex = deletedDfsTree[i].children.indexOf(deleteNodeId);
            if(childIdIndex != -1) {
                deletedDfsTree[i].children(childIdIndex,1);
            }
        }
        return deletedDfsTree;
    }

    function dfs(nodes, visitingNode, beforeNode){
        isVisited[getNodeIndex(nodes, visitingNode.id)] = true;
        // 訪問時操作開始
        let visitingIndex = getNodeIndex(nodes, visitingNode.id);
        ordArray[visitingIndex] = ordNum;
        lowArray[visitingIndex] = ordNum;
        ordNum += 1;
        // 訪問時操作終了
        let neighborNodes = getNodeDeletedNodes(getNeighborNodes(visitingNode, nodes), beforeNode);
        neighborNodes.forEach(node => {
            let nextIndex = getNodeIndex(nodes, node.id);
            if(!isVisited[nextIndex] && nextIndex!==-1) {
                dfsTree.forEach((t,i)=>{if(t.parent==visitingNode.id)dfsTree[i].children.push(node.id);});
                dfs(nodes, node, visitingNode);
                if(lowArray[visitingIndex] > lowArray[nextIndex]) lowArray[visitingIndex] = lowArray[nextIndex];
            } else { //行こうとした先が訪問済だった時
                if(lowArray[visitingIndex]>ordArray[nextIndex]) lowArray[visitingIndex] = ordArray[nextIndex];
            }
        })
    }

    function getNodeDeletedNodes(nodes, node){
        let resNodes = [];
        for(let i=0;i<nodes.length;i++){
            if(nodes[i].id!=node.id){
                resNodes.push(nodes[i].deepCopy());
            }
        }
        return resNodes;
    }

    // coloring
    function doColoring(){
        do{
            let beforeCalcNodes = getNodesCopy(Nodes);//操作前のノード達を避難
            let calcNodes = getRandomElements(beforeCalcNodes);//ランダムで複数個のノードを取得
            for(let i=0;i<calcNodes.length;i++){
                //各ノードで計算, 内部情報の更新
                calcingNode = calcNodes[i];
                let neighborNodes = getNeighborNodes(calcingNode, beforeCalcNodes);//操作前の隣人達
                if(isOutBiggerThan2(neighborNodes, calcingNode)){ // if Out(i)>2
                    Nodes[getNodeIndex(Nodes, calcingNode.id)].p =  getMaxX(neighborNodes)+1;
                }else if(isInColor(getOutEdges(neighborNodes, calcingNode), calcingNode.c)){
                    let tempNode = Nodes[getNodeIndex(Nodes, calcingNode.id)];
                    tempNode.c = getMinColor(getOutEdges(neighborNodes, calcingNode));
                    Nodes[getNodeIndex(Nodes, calcingNode.id)] = tempNode.deepCopy();
                }
            }
            // redrawCanvas();
        }while(isColoring());//彩色が終わるまで
        redrawCanvas();
        console.log("coloring finish")
    }

    function isColoring(){
        for(let i=0;i<Nodes.length;i++){
            let node = Nodes[i];
            let neighborNodes = getNeighborNodes(node, Nodes);
            for(let j=0;j<neighborNodes.length;j++){
                if(node.c == neighborNodes[j].c) return true;
            }
        }
        return false;
    }

    function getMinColor(outNodes){
        let tempColors = [0,1,2];
        outNodes.forEach(node=>{
            let res = tempColors.indexOf(node.c);
            if(res!==-1){
                tempColors.splice(res,1);
            }
        })
        let res = tempColors.reduce(function (a, b) {return Math.min(a, b);}); 
        return res;
    }

    function getOutEdges(neighborNodes, node){ //出辺先のノードの配列
        let outEdges = [];
        neighborNodes.forEach(neighbor => {
            if(neighbor.p>node.p) outEdges.push(neighbor);
            else if(neighbor.p==node.p && neighbor.id>node.id) outEdges.push(neighbor); 
        })
        return outEdges;
    }

    function isInColor(nodes, c){
        let b = false;
        nodes.forEach(node=>{
            if(node.c == c)b = true;
        })
        return b;
    }

    function getMaxX(nodes){
        let M = -1;
        nodes.forEach(node=>{
            if(node.p > M) M = node.p;
        })
        return M;
    }

    function isOutBiggerThan2(neighbors, node){
        let cnt = 0;
        neighbors.forEach(neighbor => {
            if(neighbor.p>node.p) cnt += 1;
            else if(neighbor.p==node.p && neighbor.id>node.id) cnt += 1; 
        })
        return cnt>2;
    }

    function getNeighborNodes(node, nodes){
        let neighborNodes = [];
        Edges.forEach(edge => {
            if(edge.start==node.id && isIdInNodes(nodes, edge.end)) neighborNodes.push(nodes[getNodeIndex(nodes, edge.end)].deepCopy());
            else if(edge.end==node.id  && isIdInNodes(nodes, edge.start)) neighborNodes.push(nodes[getNodeIndex(nodes, edge.start)].deepCopy());
        })
        return neighborNodes;
    }

    function getRandomElements(array){
        return array.filter(function(){
            return Math.random()>0.5;
        });
    }

    function getEdgesCopy(edges){
        let resEdges = [];
        edges.forEach(edge=>{
            resEdges.push(getEdgeCopy(edge));
        })
        return resEdges;
    }

    function getEdgeCopy(edge){
        return {start:edge.start, end:edge.end};
    }

    function getNodesCopy(nodes){
        let resNodes = [];
        nodes.forEach(node=>{
            resNodes.push(node.deepCopy());
        })
        return resNodes;
    }

    function getGraphsCopy(graphs){
        let resGraphs = [];
        graphs.forEach(graph => {
            resGraphs.push(getNodesCopy(graph));
        })
        return resGraphs;
    }

    class Node{
        constructor(x,y,id,p,c,vx,vy){
            this.x = x; 
            this.y = y;
            this.id = id; //ノード識別子
            this.p = p; //優先度決める値 
            this.c = c; //色 
            this.vx = vx;
            this.vy = vy;
        }
        
        deepCopy(){
            return new Node(this.x, this.y, this.id, this.p, this.c, this.vx, this.vy);
        }
    }
</script>
</body>
</html>
